[
    {
        "id": "cses-restaurant-customers",
        "title": "題解 CSES - Restaurant Customers",
        "content": "# 題解 CSES - Restaurant Customers\nhttps://cses.fi/problemset/result/6019372/\n## 題意\n給你 n 位客人的進入和離開餐廳的時間 \\\n輸出最多同時有幾位客人同時在餐廳\n- $n \\le 2 \\times 10^5$\n\n## 想法\n把每個人加入時間和離開的時間分別看成兩個時間點 \\\n並把所有時間點加入陣列後一起排序 \\\n然後用一個變數來維護目前餐廳人數 \\\n每次遇到加入就增加 \\\n反之遇到離開就減少 \\\n維護中遇到的最大值就是答案了\n\n![](https://github.com/dada878/blog/blob/master/assets/2023-09-02-04-19-14.png?raw=true)\n## 實作\n```cpp\n#include <bits/stdc++.h>\n#define int long long\n \nusing namespace std;\n \nsigned main() {\n\tint n;\n\tcin >> n;\n\tvector<pii> v;\n\tfor (int i = 0; i < n; i++) {\n\t\tint s, t;\n\t\tcin >> s >> t;\n\t\tv.push_back({s, true});\n\t\tv.push_back({t, false});\n\t}\n\tsort(v.begin(), v.end());\n\tint cur = 0;\n\tint ans = 0;\n\tfor (auto e : v) {\n\t\tif (e.ss == true) cur++;\n\t\telse cur--;\n\t\tans = max(cur, ans);\n\t}\n\tcout << ans << endl;\n}\n```",
        "category": "競程"
    },
    {
        "id": "graph-shortest-path",
        "title": "很多最短路演算法",
        "content": "# 很多最短路演算法\n## Dijkstra\n### 概念\n每次選擇最近的節點 \\\n嘗試透過該節點來更新相鄰節點距離\n### 實作\n將所有節點距離初始化為 $\\infty$ ( 起點為 0 ) \\\n選擇目前距離起點最近的節點 \\\n如果目前節點距離加上相鄰節點與目前節點距離小於起點到相鄰節點的距離就更新\n### 程式碼\n```cpp\nfor (int i = 1; i <= n; i++) distance[i] = INF;\ndistance[x] = 0;\nq.push({0, x});\nwhile (!q.empty()) {\n\tint a = q.top().second; q.pop();\n    // 絕對不會更新到的話直接 continue 掉\n    if (a.first > dist[now.second]) continue;\n\tfor (auto u : adj[a]) {\n\t\tint b = u.first, w = u.second;\n\t\tif (distance[a] + w < distance[b]) {\n\t\t\tdistance[b] = distance[a] + w;\n            // 因為要讓距離小的排在前面所以加負號\n\t\t\tq.push({-distance[b], b});\n\t\t}\n\t}\n}\n```\n## Floyd-WarShall\n### 概念\n這個演算法是由某個 DP 概念延伸出來的 \\\n最初的轉移式大概長這樣\n\n定義:\n\n> $dp[k][i][j]$ 為 $i$ 到 $j$ 的最短距離，且只能經過額外的 $k$ 個點\n\n轉移式:\n\n> $\\mathrm {dp} (i,j,k)=\\mathrm {min} {\\Big (}\\mathrm {dp} (i,j,k-1),\\mathrm {dp} (i,k,k-1)+\\mathrm {dp} (k,j,k-1){\\Big )}$\n\n### 實作\n依照 DP 轉移式枚舉每個點做轉移就好了 \\\n實作上由於 k 是按照順序轉移的所以可以把空間壓到二維 \\\n記得要注意迴圈是由外而內順序是 $k$、$i$、$j$ \n\n### 程式碼\n```cpp\nfor (int k = 1; k <= n; k++) {\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\tdist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\t\t}\n\t}\n}\n```\n### 奇怪的小技巧\n如果不小心忘記寫成 $i$ $j$ $k$ 的話只要做三次就會對了 \\\n2019 年的某篇論文上提到了這點\n\n![](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fd477b2f1-0d39-4fe4-a359-31eac3004e02%2FUntitled.png?table=block&id=033abae1-3cc2-443d-ab3a-59a5b6e68366&spaceId=090471c9-4258-4339-8654-7be181344180&width=1720&userId=72aeb5d8-6609-42c6-8c49-344fc9073da7&cache=v2)\n\n### 判斷負環\n如果任一個 $dist[i][i] < 0$ 若且唯若存在負環 \\\n代表有一個點自己繞一圈回到自己距離小於 0 \\\n但如果是無向圖的話的負環就很難判斷了\n\n## Bellman-Ford\n### 概念\n對於每個邊嘗試更新連接的兩個點對於起點的距離\n### 實作\n重複 n-1 次嘗試更新所有的邊\n### 程式碼\n```cpp\nfor (int i = 1; i <= n; i++) dist[i] = INF;\n\tdist[x] = 0;\n\tfor (int i = 1; i <= n-1; i++) {\n\t\tfor (auto e : edges) {\n\t\t\tint a, b, w;\n\t\t\ttie(a, b, w) = e;\n\t\t\tdist[b] = min(dist[b], dist[a] + w);\n\t\t}\n\t}\n}\n```\n### 判斷負環\n如果更新了 n-1 次還能繼續更新 \\\n代表這張圖存在負環\n## 結論\n看完這些之後 \\\n想必一定有人會覺得「為什麼要學這麼多種最短路演算法」 \\\n原因很簡單，因為這些演算法各自有不同的特性與效率 \\\n所以需要適時挑選適合的演算法來使用\n\n|  | Bellman-Ford | Dijkstra | Floyd-Warshall |\n| --- | --- | --- | --- |\n| 類型 |  單點源 | 單點源 | 全點對 |\n| 限制 | 任意圖 | 無負邊 | 任意圖 |\n| 時間複雜度 | $O(VE)$ | $O(E log E)$ | $O(V^3)$ |\n| 用途 | 檢查負環 | 快速單點源 | 全點對 |",
        "category": "競程"
    },
    {
        "id": "what-is-offline-algorithm",
        "title": "離線演算法是什麼？可以吃嗎？",
        "content": "# 離線演算法是什麼？可以吃嗎？\n",
        "category": "競程"
    }
]