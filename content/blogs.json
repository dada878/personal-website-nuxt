[
    {
        "id": "graph-shortest-path",
        "title": "很多最短路演算法",
        "content": "# 很多最短路演算法\n## Dijkstra\n### 概念\n每次選擇最近的節點 \\\n嘗試透過該節點來更新相鄰節點距離\n### 實作\n將所有節點距離初始化為 $\\infty$ ( 起點為 0 ) \\\n選擇目前距離起點最近的節點 \\\n如果目前節點距離加上相鄰節點與目前節點距離小於起點到相鄰節點的距離就更新\n### 程式碼\n```cpp\nfor (int i = 1; i <= n; i++) distance[i] = INF;\ndistance[x] = 0;\nq.push({0, x});\nwhile (!q.empty()) {\n\tint a = q.top().second; q.pop();\n    // 絕對不會更新到的話直接 continue 掉\n    if (a.first > dist[now.second]) continue;\n\tfor (auto u : adj[a]) {\n\t\tint b = u.first, w = u.second;\n\t\tif (distance[a] + w < distance[b]) {\n\t\t\tdistance[b] = distance[a] + w;\n            // 因為要讓距離小的排在前面所以加負號\n\t\t\tq.push({-distance[b], b});\n\t\t}\n\t}\n}\n```\n## Floyd-WarShall\n### 概念\n這個演算法是由某個 DP 概念延伸出來的 \\\n最初的轉移式大概長這樣\n\n定義:\n\n> $dp[k][i][j]$ 為 $i$ 到 $j$ 的最短距離，且只能經過額外的 $k$ 個點\n\n轉移式:\n\n> $\\mathrm {dp} (i,j,k)=\\mathrm {min} {\\Big (}\\mathrm {dp} (i,j,k-1),\\mathrm {dp} (i,k,k-1)+\\mathrm {dp} (k,j,k-1){\\Big )}$\n\n### 實作\n依照 DP 轉移式枚舉每個點做轉移就好了 \\\n實作上由於 k 是按照順序轉移的所以可以把空間壓到二維 \\\n記得要注意迴圈是由外而內順序是 $k$、$i$、$j$ \n\n### 程式碼\n```cpp\nfor (int k = 1; k <= n; k++) {\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\tdist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\t\t}\n\t}\n}\n```\n### 奇怪的小技巧\n如果不小心忘記寫成 $i$ $j$ $k$ 的話只要做三次就會對了 \\\n2019 年的某篇論文上提到了這點\n\n![](https://dada878.tk/images/3137aa53c8deb054de9b774cfe7e2ab7.png)\n\n### 判斷負環\n如果任一個 $dist[i][i] < 0$ 若且唯若存在負環 \\\n代表有一個點自己繞一圈回到自己距離小於 0 \\\n但如果是無向圖的話的負環就很難判斷了\n\n## Bellman-Ford\n### 概念\n對於每個邊嘗試更新連接的兩個點對於起點的距離\n### 實作\n重複 n-1 次嘗試更新所有的邊\n### 程式碼\n```cpp\nfor (int i = 1; i <= n; i++) dist[i] = INF;\n\tdist[x] = 0;\n\tfor (int i = 1; i <= n-1; i++) {\n\t\tfor (auto e : edges) {\n\t\t\tint a, b, w;\n\t\t\ttie(a, b, w) = e;\n\t\t\tdist[b] = min(dist[b], dist[a] + w);\n\t\t}\n\t}\n}\n```\n### 判斷負環\n如果更新了 n-1 次還能繼續更新 \\\n代表這張圖存在負環\n## 結論\n看完這些之後 \\\n想必一定有人會覺得「為什麼要學這麼多種最短路演算法」 \\\n原因很簡單，因為這些演算法各自有不同的特性與效率 \\\n所以需要適時挑選適合的演算法來使用\n\n|  | Bellman-Ford | Dijkstra | Floyd-Warshall |\n| --- | --- | --- | --- |\n| 類型 |  單點源 | 單點源 | 全點對 |\n| 限制 | 任意圖 | 無負邊 | 任意圖 |\n| 時間複雜度 | $O(VE)$ | $O(E log E)$ | $O(V^3)$ |\n| 用途 | 檢查負環 | 快速單點源 | 全點對 |",
        "category": "Algorithms"
    },
    {
        "id": "cses-common-divisors",
        "title": "題解 CSES - Common Divisors",
        "content": "# 題解 CSES - Common Divisors\nhttps://cses.fi/problemset/task/1081/\n## 題意\n找到兩個數字 \\\n使得兩數的最大公因數盡量大\n## 想法\n可以把題目想成 \\\n找到最大的 x 使得陣列中出現至少兩個他的倍數 \\\n於是我們可以先用 $cnt$ 陣列紀錄每個數字的出現次數 \\\n然後枚舉每個可能的因數 (假設目前枚舉到 k) \\\n從 $k$、$2k$、$3k$ $\\dots$ 計算陣列中存在多少個倍數 \\\n根據[調和級數](./harmonic-series)可以算出時間複雜度為 $O(n \\log n)$\n## 實作\n```cpp\n#include <bits/stdc++.h>\n#define int long long\n\nconst int maxn = 1e6 + 10;\nint cnt[maxn];\n\nsigned main() {\n    int n;\n    cin >> n;\n    vector<int> v(n);\n    for (int i = 0; i < n; i++) {\n        cin >> v[i];\n        cnt[v[i]]++;\n    }\n    for (int k = maxn; k > 0; k--) {\n        int cur = 0;\n        for (int j = k; j < maxn; j += k) {\n            cur += cnt[j];\n        }\n        if (cur >= 2) {\n            cout << k << endl;\n            return 0;\n        }\n    }\n}\n```",
        "category": "CSES"
    },
    {
        "id": "cses-increasing-array",
        "title": "題解 CSES - Increasing Array",
        "content": "# 題解 CSES - Increasing Array\nhttps://cses.fi/problemset/task/1094/\n## 題意\n給你一個陣列 \\\n每次修改可以讓任何一個元素的值加一 \\\n最少需要修改幾次才能讓整個陣列變成非嚴格遞增的\n## 想法\n從陣列左邊往右邊掃過去 \\\n遇到凹洞就把它填滿 \\\n計算總共需要花多少成本\n\n![](https://dada878.tk/images/5d8d3454e39752fc267314e99441ae4b.png)\n## 程式碼\n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nmain() {\n\tios_base::sync_with_stdio(false);cin.tie(0);\n\tint n;\n\tcin >> n;\n\tint ans = 0;\n\tvector<int> vec(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> vec[i];\n\t}\n\tfor (int i = 1; i < n; i++) {\n\t\tif (vec[i-1] > vec[i]) {\n\t\t\tans += vec[i-1] - vec[i];\n\t\t\tvec[i] = vec[i-1];\n\t\t}\n\t}\n\tcout << ans;\n}\n```",
        "category": "CSES"
    },
    {
        "id": "cses-missing-number",
        "title": "題解 CSES - Missing Number",
        "content": "# 題解 CSES - Missing Number\nhttps://cses.fi/problemset/task/1083/\n## 題意\n給予一堆數字 $1 \\sim n$ 但中間缺少了一個 \\\n你的任務是找出那個缺少的數字\n## 想法\n已知數字 $1 \\sim n$ 的總和為 $\\sum^n_{k=1}k$ \\\n可以透過梯形公式 $\\frac{n(1 + n)}{2}$ 快速求出來 \\\n所以我們只要用期望的 $1 \\sim n$ 總和減掉輸入的所有數字就可以算出答案了\n## 程式碼\n```cpp\n#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n \nmain() {\n\tios_base::sync_with_stdio(false);cin.tie(0);\n\tint n, sum = 0;\n\tcin >> n;\n\tfor (int i = 0; i < n-1; i++) {\n\t\tint tmp;\n\t\tcin >> tmp;\n\t\tsum += tmp;\n\t}\n\tcout << ((1 + n) * n) / 2 - sum << endl;\n}\n```",
        "category": "CSES"
    },
    {
        "id": "cses-permutations",
        "title": "題解 CSES - Permutations",
        "content": "# 題解 CSES - Permutations\nhttps://cses.fi/problemset/task/1070/\n## 題意\n給予一個數字 $n$ \\\n你要使用數字 $1 \\sim n$ 構造一個陣列 \\\n使得不存在任意兩個相鄰數字的差為 1\n## 想法\n把 $n$ 個數字分成 $1 \\sim \\lfloor \\frac{n}{2} \\rfloor$ 和 $\\lfloor \\frac{n}{2}+1 \\rfloor \\sim n$ 兩堆 \\\n並穿插構造 $ans$ 陣列就可以保證任兩數的差大約為 $\\lfloor\\frac{n}{2}\\rfloor$ \\\n最後跑過整個陣列驗證是否合法即可\n\n![](https://dada878.tk/images/bcb8a73ad185ab58bd0e9d512b2edc8f.png)\n## 程式碼\n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nsigned main() {\n\tios_base::sync_with_stdio(false);cin.tie(0);\n\tint n;\n\tcin >> n;\n\tvector<int> arr(n);\n\tdeque<int> ans;\n\tint mid = n/2;\n\tfor (int i = 1; i <= n/2; i ++) {\n\t\tint leftVal = i;\n\t\tint rightVal = mid + i;\n\t\tans.push_back(rightVal);\n\t\tans.push_back(leftVal);\n\t}\n\tif ((n & 1) == 1) {\n\t\tans.push_front(mid + n/2 +1);\n\t}\n\tfor (int i = 0; i < n-1; i++) {\n\t\tif (abs(ans[i+1] - ans[i]) == 1) {\n\t\t\tcout << \"NO SOLUTION\" << endl;\n\t\t\treturn 0 ;\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i ++) {\n\t\tcout << ans[i] << \" \";\n\t}\n\tcout << endl;\n}\n```",
        "category": "CSES"
    },
    {
        "id": "cses-repetitions",
        "title": "題解 CSES - Repetitions",
        "content": "# 題解 CSES - Repetitions\nhttps://cses.fi/problemset/task/1069\n## 題意\n你有一個由 A、C、G、T 組成的字串 \\\n目標是算出同樣的字母最多連續重複幾次\n## 想法\n把整個字串從左邊往右掃 \\\n用一個 $curLen$ 變數維護目前的長度 \\\n遇到一個字母時 $curLen$ 加 $1$ \\\n如果跟上個字母不同就把 $curLen$ 歸零 \\\n每次掃過一個字母再用 $maxLen$ 維護出現過最大的 $curLen$\n## 程式碼\n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nsigned main() {\n\tchar chr, tmp = 'X';\n\tint maxLen = 1, curLen = 1;\n\twhile (cin >> chr) {\n\t\tif (tmp != 'X' && tmp == chr) {\n\t\t\tcurLen++;\n\t\t} else {\n\t\t\tcurLen = 1;\n\t\t}\n\t\tmaxLen = max(maxLen, curLen);\n\t\ttmp = chr;\n\t}\n\tcout << maxLen << endl;\n}\n```",
        "category": "CSES"
    },
    {
        "id": "cses-restaurant-customers",
        "title": "題解 CSES - Restaurant Customers",
        "content": "# 題解 CSES - Restaurant Customers\nhttps://cses.fi/problemset/task/1619/\n## 題意\n給你 n 位客人的進入和離開餐廳的時間 \\\n輸出最多同時有幾位客人同時在餐廳\n- $n \\le 2 \\times 10^5$\n\n## 想法\n把每個人加入時間和離開的時間分別看成兩個時間點 \\\n並把所有時間點加入陣列後一起排序 \\\n然後用一個變數來維護目前餐廳人數 \\\n每次遇到加入就增加 \\\n反之遇到離開就減少 \\\n維護中遇到的最大值就是答案了 \\\n時間複雜度：$O(n)$\n\n![](https://dada878.tk/images/d5aa116365d28cc4e09a1005ce3a7d14.png)\n## 實作\n```cpp\n#include <bits/stdc++.h>\n#define int long long\n \nusing namespace std;\n \nsigned main() {\n\tint n;\n\tcin >> n;\n\tvector<pii> v;\n\tfor (int i = 0; i < n; i++) {\n\t\tint s, t;\n\t\tcin >> s >> t;\n\t\tv.push_back({s, true});\n\t\tv.push_back({t, false});\n\t}\n\tsort(v.begin(), v.end());\n\tint cur = 0;\n\tint ans = 0;\n\tfor (auto e : v) {\n\t\tif (e.ss == true) cur++;\n\t\telse cur--;\n\t\tans = max(cur, ans);\n\t}\n\tcout << ans << endl;\n}\n```",
        "category": "CSES"
    },
    {
        "id": "cses-sum-of-divisors",
        "title": "題解 CSES - Sum of Divisors",
        "content": "# 題解 CSES - Sum of Divisors\nhttps://cses.fi/problemset/task/1082/\n## 題意\n定義 $f(x)$ 為 $x$ 的所有因數之和 \\\n給予一個 $n$ 求 $\\sum^n_{k=1}f(k)$ 之值\n## 想法\n以 $12$ 為例 \\\n先看一下這張圖列出了 $1 \\sim 12$ 的所有因數\n\n![](https://dada878.tk/images/b56e50faceeb4a7a002c7782c10d8c87.png)\n\n可以發現每兩個數字就會出現一次 $2$ \\\n每三次數字就會出現一次 $3$ \\\n觀察後可知 \\\n對於一個數字 $x$ 它的出現次數會是 $\\lfloor \\frac{n}{x} \\rfloor$ \\\n因為每 $x$ 個數字就會出現一個 $x$ 的倍數 \\\n用這個做法枚舉每個數字計算就可以得到一個 $O(n)$ 的算法 \\\n但這樣還不夠快到足以處理這題 $10^{12}$ 的資料量\n\n如果我們把剛剛那張圖的呈現方式改一下 \\\n上面那一橫排代表因數 $1 \\sim 12$ \\\n下面那一行排代表該因數出現的次數\n\n![](https://dada878.tk/images/4522eb0f044d3595ce3ab2df1f0b06a6.png)\n\n可以發現這張圖內有幾串連續的因數出現次數相同 \\\n因為事實上在計算這個的過程中只會出現最多 $2 \\sqrt n$ 個相異數字 ([證明](https://youtu.be/JqWiWJQOQyU?si=R22VRyfJeZ4k3Ijy&t=451))\n\n\n上面那張圖每個紅色圈起來代表一塊 \\\n如果我們可以塊為單位來計算就可以把時間複雜度降到 $O(\\sqrt{n})$ 了\n\n想像一下 \\\n如果 $n$ 除以 $x$ 可以剛好整除的話 \\\n令 $k = \\lfloor \\frac{n}{x} \\rfloor$ 則 $\\lfloor \\frac{n}{k} \\rfloor$ 必定等於 $k$ \\\n那如果不是剛好整除的呢？ \\\n$\\lfloor \\frac{12}{5} \\rfloor = 2 ,\\quad\\lfloor \\frac{12}{2} \\rfloor = 6$ \\\n再試試看 $6$ \\\n$\\lfloor \\frac{12}{6} \\rfloor = 2 ,\\quad\\lfloor \\frac{12}{2} \\rfloor = 6$ \\\n觀察後發現 \\\n這裡的 $6$ 就是最大的 $x$ 滿足 $\\frac{n}{x}$ 為 $2$ \\\n於是這樣我們就可以找到最後一個連續出現次數相同的因數 \\\n最後只要把每次一塊的第一個數和最後一個數用梯形公式求總和乘上共同的出現次數就可以得到答案了\n\n不過這邊要注意的是 \\\n因為答案很大所以題目要我們對 $10^9 + 7$ 取模 \\\n但梯形公式中又會用到除法 \\\n所以我們不能直接除 \\\n需要先求出[模反元素](./modulo-inverse)再乘進去才行\n## 程式碼\n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nconst int mod = 1e9 + 7;\nconst int inv = 500000004;\n \nsigned main() {\n    int n;\n    cin >> n;\n    int cur = 1;\n    int ans = 0;\n    while (cur <= n) {\n        int cnt = n / cur;\n        int last = n / cnt;\n        int sum = ((((last + cur) % mod) * ((last - cur + 1) % mod) % mod) * inv) % mod;\n        ans += ((sum % mod) * (cnt % mod)) % mod;\n        cur = last + 1;\n    }\n    cout << ans % mod << endl;\n}\n```",
        "category": "CSES"
    },
    {
        "id": "cses-weird-algorithm",
        "title": "題解 CSES - Weird Algorithm",
        "content": "# 題解 CSES - Weird Algorithm\nhttps://cses.fi/problemset/task/1068\n## 題意\n給予一個數字 $n$ \\\n如果他是偶數就把他除 $2$ \\\n否則就把他乘 $3$ 再加 $1$ \\\n重複直到 $n$ 變成 $1$\n## 想法\n沒什麼特別的概念 \\\n直接模擬操作就可以了\n## 程式碼\n```cpp\n#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\nsigned main() {\n\tint n;\n\tcin >> n;\n\twhile(n != 1) {\n\t\tcout << n << \" \";\n\t\tif (n & 1 == 1) {\n\t\t\t n *= 3;\n\t\t\t n++;\n\t\t} else {\n\t\t\tn /= 2;\n\t\t}\n\t}\n\tcout << 1 << endl;\n}\n```",
        "category": "CSES"
    },
    {
        "id": "harmonic-series",
        "title": "調和級數",
        "content": "# 調和級數\n## 簡介\n一個在因倍數相關題目可以用到的小技巧 \\\n程式碼大概像這樣 \\\n可以得到 $O(n \\log n)$ 的時間複雜度\n```cpp\nfor (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j += i) {\n        // to something\n    }\n}\n```\n## 公式\n$n \\log n \\approx \\sum_{k=1}^n \\frac 1 k =  1 + \\frac 1 2 + \\frac 1 3 + \\frac 1 4 + \\cdots + \\frac 1 n$ \\\n<br />\n![](https://dada878.tk/images/48602d9237fb83760f2bb7eb23974398.png)\n## 例題\nhttps://codeforces.com/contest/1850/problem/F \\\nhttps://cses.fi/problemset/task/1081/",
        "category": "Math"
    },
    {
        "id": "modulo-inverse",
        "title": "模反元素",
        "content": "# 模反元素\n頁面待完成...",
        "category": "Math"
    }
]