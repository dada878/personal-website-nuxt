[
    {
        "id": "cses-common-divisors",
        "title": "題解 CSES - Common Divisors",
        "content": "# 題解 CSES - Common Divisors\nhttps://cses.fi/problemset/task/1081/\n## 題意\n找到兩個數字 \\\n使得兩數的最大公因數盡量大\n## 想法\n可以把題目想成 \\\n找到最大的 x 使得陣列中出現至少兩個他的倍數 \\\n於是我們可以先用 $cnt$ 陣列紀錄每個數字的出現次數 \\\n然後枚舉每個可能的因數 (假設目前枚舉到 k) \\\n從 $k$、$2k$、$3k$ $\\dots$ 計算陣列中存在多少個倍數 \\\n根據[調和級數](./harmonic-series)可以算出時間複雜度為 $O(n \\log n)$\n## 實作\n```cpp\n#include <bits/stdc++.h>\n#define int long long\n\nconst int maxn = 1e6 + 10;\nint cnt[maxn];\n\nsigned main() {\n    int n;\n    cin >> n;\n    vector<int> v(n);\n    for (int i = 0; i < n; i++) {\n        cin >> v[i];\n        cnt[v[i]]++;\n    }\n    for (int k = maxn; k > 0; k--) {\n        int cur = 0;\n        for (int j = k; j < maxn; j += k) {\n            cur += cnt[j];\n        }\n        if (cur >= 2) {\n            cout << k << endl;\n            return 0;\n        }\n    }\n}\n```",
        "category": "CSES"
    },
    {
        "id": "cses-increasing-array",
        "title": "CSES 題解 - Increasing Array",
        "content": "# CSES 題解 - Increasing Array\nhttps://cses.fi/problemset/task/1094/\n## 題意\n給你一個陣列 \\\n每次修改可以讓任何一個元素的值加一 \\\n最少需要修改幾次才能讓整個陣列變成非嚴格遞增的\n## 想法\n從陣列左邊往右邊掃過去 \\\n遇到凹洞就把它填滿 \\\n計算總共需要花多少成本 \\\n![](https://github.com/dada878/blog/blob/master/assets/Snipaste_2023-09-09_21-36-33.png?raw=true)\n## 程式碼\n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nmain() {\n\tios_base::sync_with_stdio(false);cin.tie(0);\n\tint n;\n\tcin >> n;\n\tint ans = 0;\n\tvector<int> vec(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> vec[i];\n\t}\n\tfor (int i = 1; i < n; i++) {\n\t\tif (vec[i-1] > vec[i]) {\n\t\t\tans += vec[i-1] - vec[i];\n\t\t\tvec[i] = vec[i-1];\n\t\t}\n\t}\n\tcout << ans;\n}\n```",
        "category": "CSES"
    },
    {
        "id": "cses-missing-number",
        "title": "題解 CSES - Missing Number",
        "content": "# 題解 CSES - Missing Number\nhttps://cses.fi/problemset/task/1083/\n## 題意\n給予一堆數字 $1 \\sim n$ 但中間缺少了一個 \\\n你的任務是找出那個缺少的數字\n## 想法\n已知數字 $1 \\sim n$ 的總和為 $\\sum^n_{k=1}k$ \\\n可以透過梯形公式 $\\frac{n(1 + n)}{2}$ 快速求出來 \\\n所以我們只要用期望的 $1 \\sim n$ 總和減掉輸入的所有數字就可以算出答案了\n## 程式碼\n```cpp\n#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n \nmain() {\n\tios_base::sync_with_stdio(false);cin.tie(0);\n\tint n, sum = 0;\n\tcin >> n;\n\tfor (int i = 0; i < n-1; i++) {\n\t\tint tmp;\n\t\tcin >> tmp;\n\t\tsum += tmp;\n\t}\n\tcout << ((1 + n) * n) / 2 - sum << endl;\n}\n```",
        "category": "CSES"
    },
    {
        "id": "cses-permutations",
        "title": "CSES 題解 - Permutations",
        "content": "# CSES 題解 - Permutations\nhttps://cses.fi/problemset/task/1070/\n## 題意\n給予一個數字 $n$ \\\n你要使用數字 $1 \\sim n$ 構造一個陣列 \\\n使得不存在任意兩個相鄰數字的差為 1\n## 想法\n把 $n$ 個數字分成 $1 \\sim \\lfloor \\frac{n}{2} \\rfloor$ 和 $\\lfloor \\frac{n}{2}+1 \\rfloor \\sim n$ 兩堆 \\\n並穿插構造 $ans$ 陣列就可以保證任兩數的差大約為 $\\frac{n}{2}$ \\\n最後跑過整個陣列驗證是否合法即可 \\\n![](https://github.com/dada878/blog/blob/master/assets/Snipaste_2023-09-09_21-50-43.png?raw=true)\n## 程式碼\n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nsigned main() {\n\tios_base::sync_with_stdio(false);cin.tie(0);\n\tint n;\n\tcin >> n;\n\tvector<int> arr(n);\n\tdeque<int> ans;\n\tint mid = n/2;\n\tfor (int i = 1; i <= n/2; i ++) {\n\t\tint leftVal = i;\n\t\tint rightVal = mid + i;\n\t\tans.push_back(rightVal);\n\t\tans.push_back(leftVal);\n\t}\n\tif ((n & 1) == 1) {\n\t\tans.push_front(mid + n/2 +1);\n\t}\n\tfor (int i = 0; i < n-1; i++) {\n\t\tif (abs(ans[i+1] - ans[i]) == 1) {\n\t\t\tcout << \"NO SOLUTION\" << endl;\n\t\t\treturn 0 ;\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i ++) {\n\t\tcout << ans[i] << \" \";\n\t}\n\tcout << endl;\n}\n```",
        "category": "CSES"
    },
    {
        "id": "cses-repetitions",
        "title": "題解 CSES - Repetitions",
        "content": "# 題解 CSES - Repetitions\nhttps://cses.fi/problemset/task/1069\n## 題意\n你有一個由 A、C、G、T 組成的字串 \\\n目標是算出同樣的字母最多連續重複幾次\n## 想法\n把整個字串從左邊往右掃 \\\n用一個 $curLen$ 變數維護目前的答案 \\\n遇到一個字母時 $curLen$ 加 $1$ \\\n如果跟上個字母不同就把 $curLen$ 歸零 \\\n每次掃過一個字母再用 $maxLen$ 維護出現過最大的 $curLen$\n## 程式碼\n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nsigned main() {\n\tchar chr, tmp = 'X';\n\tint maxLen = 1, curLen = 1;\n\twhile (cin >> chr) {\n\t\tif (tmp != 'X' && tmp == chr) {\n\t\t\tcurLen++;\n\t\t} else {\n\t\t\tcurLen = 1;\n\t\t}\n\t\tmaxLen = max(maxLen, curLen);\n\t\ttmp = chr;\n\t}\n\tcout << maxLen << endl;\n}\n```",
        "category": "CSES"
    },
    {
        "id": "cses-restaurant-customers",
        "title": "題解 CSES - Restaurant Customers",
        "content": "# 題解 CSES - Restaurant Customers\nhttps://cses.fi/problemset/task/1619/\n## 題意\n給你 n 位客人的進入和離開餐廳的時間 \\\n輸出最多同時有幾位客人同時在餐廳\n- $n \\le 2 \\times 10^5$\n\n## 想法\n把每個人加入時間和離開的時間分別看成兩個時間點 \\\n並把所有時間點加入陣列後一起排序 \\\n然後用一個變數來維護目前餐廳人數 \\\n每次遇到加入就增加 \\\n反之遇到離開就減少 \\\n維護中遇到的最大值就是答案了 \\\n時間複雜度：$O(n)$\n\n![](https://github.com/dada878/blog/blob/master/assets/2023-09-02-04-19-14.png?raw=true)\n## 實作\n```cpp\n#include <bits/stdc++.h>\n#define int long long\n \nusing namespace std;\n \nsigned main() {\n\tint n;\n\tcin >> n;\n\tvector<pii> v;\n\tfor (int i = 0; i < n; i++) {\n\t\tint s, t;\n\t\tcin >> s >> t;\n\t\tv.push_back({s, true});\n\t\tv.push_back({t, false});\n\t}\n\tsort(v.begin(), v.end());\n\tint cur = 0;\n\tint ans = 0;\n\tfor (auto e : v) {\n\t\tif (e.ss == true) cur++;\n\t\telse cur--;\n\t\tans = max(cur, ans);\n\t}\n\tcout << ans << endl;\n}\n```",
        "category": "CSES"
    },
    {
        "id": "cses-weird-algorithm",
        "title": "題解 CSES - Weird Algorithm",
        "content": "# 題解 CSES - Weird Algorithm\nhttps://cses.fi/problemset/task/1068\n## 題意\n給予一個數字 $n$ \\\n如果他是偶數就把他除 $2$ \\\n否則就把他乘 $3$ 再加 $1$ \\\n重複直到 $n$ 變成 $1$\n## 想法\n沒什麼特別的概念 \\\n直接模擬操作就可以了\n## 程式碼\n```cpp\n#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\nsigned main() {\n\tint n;\n\tcin >> n;\n\twhile(n != 1) {\n\t\tcout << n << \" \";\n\t\tif (n & 1 == 1) {\n\t\t\t n *= 3;\n\t\t\t n++;\n\t\t} else {\n\t\t\tn /= 2;\n\t\t}\n\t}\n\tcout << 1 << endl;\n}\n```",
        "category": "CSES"
    },
    {
        "id": "harmonic-series",
        "title": "調和級數",
        "content": "# 調和級數\n## 簡介\n一個在因倍數相關題目可以用到的小技巧 \\\n程式碼大概像這樣 \\\n可以得到 $O(n \\log n)$ 的時間複雜度\n```cpp\nfor (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j += i) {\n        // to something\n    }\n}\n```\n## 公式\n$\\log n \\approx \\sum_{k=1}^n \\frac 1 k =  1 + \\frac 1 2 + \\frac 1 3 + \\frac 1 4 + \\cdots + \\frac 1 n$ \\\n<br />\n![](https://github.com/dada878/blog/blob/master/assets/Snipaste_2023-09-09_20-53-54.png?raw=true)\n## 例題\nhttps://codeforces.com/contest/1850/problem/F \\\nhttps://cses.fi/problemset/task/1081/",
        "category": "數學"
    },
    {
        "id": "graph-shortest-path",
        "title": "很多最短路演算法",
        "content": "# 很多最短路演算法\n## Dijkstra\n### 概念\n每次選擇最近的節點 \\\n嘗試透過該節點來更新相鄰節點距離\n### 實作\n將所有節點距離初始化為 $\\infty$ ( 起點為 0 ) \\\n選擇目前距離起點最近的節點 \\\n如果目前節點距離加上相鄰節點與目前節點距離小於起點到相鄰節點的距離就更新\n### 程式碼\n```cpp\nfor (int i = 1; i <= n; i++) distance[i] = INF;\ndistance[x] = 0;\nq.push({0, x});\nwhile (!q.empty()) {\n\tint a = q.top().second; q.pop();\n    // 絕對不會更新到的話直接 continue 掉\n    if (a.first > dist[now.second]) continue;\n\tfor (auto u : adj[a]) {\n\t\tint b = u.first, w = u.second;\n\t\tif (distance[a] + w < distance[b]) {\n\t\t\tdistance[b] = distance[a] + w;\n            // 因為要讓距離小的排在前面所以加負號\n\t\t\tq.push({-distance[b], b});\n\t\t}\n\t}\n}\n```\n## Floyd-WarShall\n### 概念\n這個演算法是由某個 DP 概念延伸出來的 \\\n最初的轉移式大概長這樣\n\n定義:\n\n> $dp[k][i][j]$ 為 $i$ 到 $j$ 的最短距離，且只能經過額外的 $k$ 個點\n\n轉移式:\n\n> $\\mathrm {dp} (i,j,k)=\\mathrm {min} {\\Big (}\\mathrm {dp} (i,j,k-1),\\mathrm {dp} (i,k,k-1)+\\mathrm {dp} (k,j,k-1){\\Big )}$\n\n### 實作\n依照 DP 轉移式枚舉每個點做轉移就好了 \\\n實作上由於 k 是按照順序轉移的所以可以把空間壓到二維 \\\n記得要注意迴圈是由外而內順序是 $k$、$i$、$j$ \n\n### 程式碼\n```cpp\nfor (int k = 1; k <= n; k++) {\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\tdist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\t\t}\n\t}\n}\n```\n### 奇怪的小技巧\n如果不小心忘記寫成 $i$ $j$ $k$ 的話只要做三次就會對了 \\\n2019 年的某篇論文上提到了這點\n\n![](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fd477b2f1-0d39-4fe4-a359-31eac3004e02%2FUntitled.png?table=block&id=033abae1-3cc2-443d-ab3a-59a5b6e68366&spaceId=090471c9-4258-4339-8654-7be181344180&width=1720&userId=72aeb5d8-6609-42c6-8c49-344fc9073da7&cache=v2)\n\n### 判斷負環\n如果任一個 $dist[i][i] < 0$ 若且唯若存在負環 \\\n代表有一個點自己繞一圈回到自己距離小於 0 \\\n但如果是無向圖的話的負環就很難判斷了\n\n## Bellman-Ford\n### 概念\n對於每個邊嘗試更新連接的兩個點對於起點的距離\n### 實作\n重複 n-1 次嘗試更新所有的邊\n### 程式碼\n```cpp\nfor (int i = 1; i <= n; i++) dist[i] = INF;\n\tdist[x] = 0;\n\tfor (int i = 1; i <= n-1; i++) {\n\t\tfor (auto e : edges) {\n\t\t\tint a, b, w;\n\t\t\ttie(a, b, w) = e;\n\t\t\tdist[b] = min(dist[b], dist[a] + w);\n\t\t}\n\t}\n}\n```\n### 判斷負環\n如果更新了 n-1 次還能繼續更新 \\\n代表這張圖存在負環\n## 結論\n看完這些之後 \\\n想必一定有人會覺得「為什麼要學這麼多種最短路演算法」 \\\n原因很簡單，因為這些演算法各自有不同的特性與效率 \\\n所以需要適時挑選適合的演算法來使用\n\n|  | Bellman-Ford | Dijkstra | Floyd-Warshall |\n| --- | --- | --- | --- |\n| 類型 |  單點源 | 單點源 | 全點對 |\n| 限制 | 任意圖 | 無負邊 | 任意圖 |\n| 時間複雜度 | $O(VE)$ | $O(E log E)$ | $O(V^3)$ |\n| 用途 | 檢查負環 | 快速單點源 | 全點對 |",
        "category": "演算法"
    }
]