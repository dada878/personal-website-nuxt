[
    {
        "id": "toi-beginners-party",
        "title": "TOI 新手同好會心得文",
        "content": "# TOI 新手同好會心得文\n## 前往師大\n有點怕遲到很早出門 \\\n結果正式開始前半小時就到師大了 \\\n不過教室已經開了 \\\n就到裡面坐著寫寫題\n\n等工作人員準備一下之後 \\\n很快就開放參與者報到了 \\\n領了名牌還有幾個師大的紀念品 \\\n因為下午團體賽要分組所以也抽了組別的籤\n\n![](https://github.com/dada878/blog/blob/master/assets/IMG_20231216_152101.jpg?raw=true)\n\n## 個人賽\n比賽時常 2.5 小時總共有 8 題 \\\n開賽後先打開了第一題 \\\n~~但看到一堆複雜的算式所以就先跳過了~~ \\\n第二題感覺就是排序裸題 \\\n~~但沒看很仔細導致看不懂題目所以也跳過了~~ \\\n第三題是字串模擬題 \\\n我決定從這題開始下手 \\\n結果因為最近用 Mac 而且家裡 Windowns 鍵盤跟比賽的差很多的關係 \\\n打字打的超痛苦 \\\n方向鍵位置差很多而且要按 ctrl 一直按到 alt \\\n寫到心態很崩 \\\n這種水題傳上去甚至還吃了一個 WA \\\n~~我甚至在想為什麼我要花時間來這裡受苦受難~~ \\\n重新看題目後發現原來完全理解錯意思了 \\\n修改一下之後總算 AC 了一題 \\\n\n翻開第四題 \\\n看到測資範圍到了 $10^5$ \\\n總算看到一題算法題了 \\\n大概花幾分鐘思考就把雙指針寫完 \\\n不過還是吃了幾次 WA \\\n加上讀題跟 debug 大概總共花了半小時才 AC 這題\n\n第五題 \\\n很明顯的水題目 \\\n簡單陣列操作而已 \\\n大概只花了幾分鐘就寫完這題 \\\nAC ! \n\n第六題 \\\n裸的 STL prority_queue 題 \\\n寫起來也還算順手 \\\n1 發 AC\n\n接下來是第七題 \\\n~~但看起來有點難所以先看第八題~~ \\\n第八題是括號運算式 + 二分搜或枚舉 \\\n不過看起來實做有點麻煩 \\\n所以先回去看前面的題目好了\n重新讀懂第二題之後花了一點時間就 AC 了\n\n回到第一題 \\\n仔細看題目之後發現 \\\n原來似乎只是要模擬計算過程而已 \\\n不過浮點數感覺很棘手 \\\n總之還是先寫在說 \\\n結果傳上去馬上吃了一個 WA \\\n花了一點時間 debug 之後獲得 20 分子題分數 \\\n不會有小數點精度問題的子題 qwq\n\n最剩下半小時我決定來寫最後一題目 \\\n把括號運算式弄好了 \\\n枚舉也做好了 \\\n不過一直吃 WA \\\n比賽就這樣結束了\n\n總分：620 \\\n打的比上次還慘\n\n## 午餐時間\n先上一張超讚的午餐圖片\n\n![](https://github.com/dada878/blog/blob/master/assets/IMG_20231216_152114.jpg?raw=true)\n\n簡單來說就是比薩＋飲料 \\\n然後系主任還有一個一個同學發巧克力 QQ 球 \\\n(系主任人超好 ><)\n\n然後吃完午餐就是頒獎跟摸彩時間 \\\n結果意外的拿了個人賽第二名 \\\n獲得了一副藍牙耳機 \\\n摸彩還摸到前幾大獎 \\\n可惜前三名不能拿摸彩獎品所以重抽了\n\n![](https://github.com/dada878/blog/blob/master/assets/IMG_20231216_152203.jpg?raw=true)\n\n接著是神奇的團康小遊戲（？ \\\n他們會發給每個人一張表格 \\\n上面有很多格子 \\\n每個格子寫著不同內容 \\\n例如「我來自雲林」、「我近視不到 200 度」、「我知道 DFS」之類的 \\\n要找符合內容的人簽名 \\\n最後先連成一條、兩條、三條線的可以獲得獎品 \\\n總之我沒成功拿到獎品就是了 QAQ\n\n## 團體賽\n這次的團體賽玩的是 [Same Game](https://www.codingame.com/ide/puzzle/samegame) \\\n簡單來說就是在盤面上找到兩個以上同色球連再一起消除得分 \\\n消除後空格會有上面的球掉下來 \\\n獲得越多分數的排名越高 \\\n不過跟一般的差別就在我們要使用程式操作這個遊戲\n\n一剛開始的想法是 \\\n有沒有可能這就是某種很酷的 dp 題目 \\\n畢竟目前狀態消除不同位置都會讓不同的球往下掉 \\\n也就會改變未來的狀態進而影響結果 \\\n不過後來想了一下沒什麼頭緒 \\\n但看到了第一步可以花 20 秒計算 \\\n於是我就想說 \\\n不如來試試看 [Minimax Algorithm](https://en.wikipedia.org/wiki/Minimax) 吧 \\\n以前做遊戲的電腦 AI 時用過 \\\n想說感覺應該可以用在這邊 \\\n(其實簡單來說就是暴力枚舉 k 步後的所有狀態在選擇最佳的走而已) \\\n花了快一個小時寫完後 \\\n結果才跑兩層記憶體就炸了 qwq \\\n嗯 預測一兩步跟沒預測一樣 \\\n所以只好果斷放棄這個做法\n\n想起剛剛在講解規則時 \\\n有提到一些策略 \\\n於是我們就先把那些能做的都做出來 \\\n主要就是兩個「先固定消一個顏色，消完再消下一個」跟「先把連通塊小的顏色消掉」 \\\n於是我們就拿了第三名 (???)\n\n帶走了一個安妮亞滑鼠墊 : D\n\n![](https://github.com/dada878/blog/blob/master/assets/IMG20231209161937.jpg?raw=true)\n\n## 結語\n整體來說還蠻好玩的 \\\n午餐很讚而且也帶了不少戰利品 \\\n還認識了一些人 (~~準確來說是只認識了一個人 TAT~~)",
        "category": "Journal",
        "date": "2024 / 01 / 01"
    },
    {
        "id": "cses-increasing-array",
        "title": "題解 CSES Increasing Array",
        "content": "# 題解 CSES Increasing Array\nhttps://cses.fi/problemset/task/1094/\n## 題意\n給你一個陣列 \\\n每次修改可以讓任何一個元素的值加一 \\\n最少需要修改幾次才能讓整個陣列變成非嚴格遞增的\n## 想法\n從陣列左邊往右邊掃過去 \\\n遇到凹洞就把它填滿 \\\n計算總共需要花多少成本\n\n![](https://github.com/dada878/blog/blob/master/assets/Snipaste_2023-09-09_21-36-33.png?raw=true)\n## 程式碼\n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nmain() {\n\tios_base::sync_with_stdio(false);cin.tie(0);\n\tint n;\n\tcin >> n;\n\tint ans = 0;\n\tvector<int> vec(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> vec[i];\n\t}\n\tfor (int i = 1; i < n; i++) {\n\t\tif (vec[i-1] > vec[i]) {\n\t\t\tans += vec[i-1] - vec[i];\n\t\t\tvec[i] = vec[i-1];\n\t\t}\n\t}\n\tcout << ans;\n}\n```",
        "category": "CSES",
        "date": "2024 / 01 / 01"
    },
    {
        "id": "cses-missing-number",
        "title": "題解 CSES Missing Number",
        "content": "# 題解 CSES Missing Number\nhttps://cses.fi/problemset/task/1083/\n## 題意\n給予一堆數字 $1 \\sim n$ 但中間缺少了一個 \\\n你的任務是找出那個缺少的數字\n## 想法\n已知數字 $1 \\sim n$ 的總和為 $\\sum^n_{k=1}k$ \\\n可以透過梯形公式 $\\frac{n(1 + n)}{2}$ 快速求出來 \\\n所以我們只要用期望的 $1 \\sim n$ 總和減掉輸入的所有數字就可以算出答案了\n## 程式碼\n```cpp\n#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n \nmain() {\n\tios_base::sync_with_stdio(false);cin.tie(0);\n\tint n, sum = 0;\n\tcin >> n;\n\tfor (int i = 0; i < n-1; i++) {\n\t\tint tmp;\n\t\tcin >> tmp;\n\t\tsum += tmp;\n\t}\n\tcout << ((1 + n) * n) / 2 - sum << endl;\n}\n```",
        "category": "CSES",
        "date": "2024 / 01 / 01"
    },
    {
        "id": "cses-restaurant-customers",
        "title": "題解 CSES Restaurant Customers",
        "content": "# 題解 CSES Restaurant Customers\nhttps://cses.fi/problemset/task/1619/\n## 題意\n給你 n 位客人的進入和離開餐廳的時間 \\\n輸出最多同時有幾位客人同時在餐廳\n- $n \\le 2 \\times 10^5$\n\n## 想法\n把每個人加入時間和離開的時間分別看成兩個時間點 \\\n並把所有時間點加入陣列後一起排序 \\\n然後用一個變數來維護目前餐廳人數 \\\n每次遇到加入就增加 \\\n反之遇到離開就減少 \\\n維護中遇到的最大值就是答案了 \\\n時間複雜度：$O(n)$\n\n![](https://github.com/dada878/blog/blob/master/assets/2023-09-02-04-19-14.png?raw=true)\n## 實作\n```cpp\n#include <bits/stdc++.h>\n#define int long long\n \nusing namespace std;\n \nsigned main() {\n\tint n;\n\tcin >> n;\n\tvector<pii> v;\n\tfor (int i = 0; i < n; i++) {\n\t\tint s, t;\n\t\tcin >> s >> t;\n\t\tv.push_back({s, true});\n\t\tv.push_back({t, false});\n\t}\n\tsort(v.begin(), v.end());\n\tint cur = 0;\n\tint ans = 0;\n\tfor (auto e : v) {\n\t\tif (e.ss == true) cur++;\n\t\telse cur--;\n\t\tans = max(cur, ans);\n\t}\n\tcout << ans << endl;\n}\n```",
        "category": "CSES",
        "date": "2024 / 01 / 01"
    },
    {
        "id": "cses-sum-of-divisors",
        "title": "題解 CSES Sum of Divisors",
        "content": "# 題解 CSES Sum of Divisors\nhttps://cses.fi/problemset/task/1082/\n## 題意\n定義 $\\sigma(x)$ 為 $x$ 的所有因數之和 \\\n給予一個 $n$ 求 $\\sum^n_{k=1}\\sigma(k)$ 之值\n## 想法\n以 $12$ 為例 \\\n先看一下這張圖列出了 $1 \\sim 12$ 的所有因數\n\n![](https://github.com/dada878/blog/blob/master/assets/Snipaste_2023-09-10_05-15-11.png?raw=true)\n\n可以發現每兩個數字就會出現一次 $2$ \\\n每三次數字就會出現一次 $3$ \\\n觀察後可知 \\\n對於一個數字 $x$ 它的出現次數會是 $\\lfloor \\frac{n}{x} \\rfloor$ \\\n因為每 $x$ 個數字就會出現一個 $x$ 的倍數 \\\n用這個做法枚舉每個數字計算就可以得到一個 $O(n)$ 的算法 \\\n但這樣還不夠快到足以處理這題 $10^{12}$ 的資料量\n\n如果我們把剛剛那張圖的呈現方式改一下 \\\n上面那一橫排代表因數 $1 \\sim 12$ \\\n下面那一行排代表該因數出現的次數\n\n![](https://github.com/dada878/blog/blob/master/assets/Snipaste_2023-09-10_05-33-56.png?raw=true)\n\n可以發現這張圖內有幾串連續的因數出現次數相同 \\\n因為事實上在計算這個的過程中只會出現最多 $2 \\sqrt n$ 個相異數字 ([證明](https://youtu.be/JqWiWJQOQyU?si=R22VRyfJeZ4k3Ijy&t=451))\n\n\n上面那張圖每個紅色圈起來代表一塊 \\\n如果我們可以塊為單位來計算就可以把時間複雜度降到 $O(\\sqrt{n})$ 了\n\n想像一下 \\\n如果 $n$ 除以 $x$ 可以剛好整除的話 \\\n令 $k = \\lfloor \\frac{n}{x} \\rfloor$ 則 $\\lfloor \\frac{n}{k} \\rfloor$ 必定等於 $k$ \\\n那如果不是剛好整除的呢？ \\\n$\\lfloor \\frac{12}{5} \\rfloor = 2 ,\\quad\\lfloor \\frac{12}{2} \\rfloor = 6$ \\\n再試試看 $6$ \\\n$\\lfloor \\frac{12}{6} \\rfloor = 2 ,\\quad\\lfloor \\frac{12}{2} \\rfloor = 6$ \\\n觀察後發現 \\\n這裡的 $6$ 就是最大的 $x$ 滿足 $\\frac{n}{x}$ 為 $2$ \\\n於是這樣我們就可以找到最後一個連續出現次數相同的因數 \\\n最後只要把每次一塊的第一個數和最後一個數用梯形公式求總和乘上共同的出現次數就可以得到答案了\n\n不過這邊要注意的是 \\\n因為答案很大所以題目要我們對 $10^9 + 7$ 取模 \\\n但梯形公式中又會用到除法 \\\n所以我們不能直接除 \\\n需要先求出[模反元素](./modulo-inverse)再乘進去才行\n## 程式碼\n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nconst int mod = 1e9 + 7;\nconst int inv = 500000004;\n \nsigned main() {\n    int n;\n    cin >> n;\n    int cur = 1;\n    int ans = 0;\n    while (cur <= n) {\n        int cnt = n / cur;\n        int last = n / cnt;\n        int sum = ((((last + cur) % mod) * ((last - cur + 1) % mod) % mod) * inv) % mod;\n        ans += ((sum % mod) * (cnt % mod)) % mod;\n        cur = last + 1;\n    }\n    cout << ans % mod << endl;\n}\n```",
        "category": "CSES",
        "date": "2024 / 01 / 01"
    },
    {
        "id": "cses-trailing-zeros",
        "title": "題解 CSES Trailing Zeros",
        "content": "# 題解 CSES Trailing Zeros\nhttps://cses.fi/problemset/result/5470956/\n# 題意\nn 階乘求數字有幾個後綴 0\n# 想法\n不難發現   \n後綴幾個 0 就等於乘進去的 10 的個數   \n而 $10 = 5 \\times 2$ \\\n所以後綴 0 數量就相當於計算把每個數質因數分解後 5 和 2 的較少的那個的個數   \n那當然 5 一定會比 2 少   \n所以我們要做的是就是計算 5 的個數   \n那要如何計算呢？   \n   \n以 30 為例   \n我們知道要求得 30 階就是要把下面這些數字乘起來   \n\n![](https://github.com/dada878/blog/blob/master/assets/image20240126.png?raw=true)\n\n不過我們可以先排除掉質因數分解後裡面沒有 5 的數字   \n然後把下面的數字都各取走一個質因數分解裡面的 5（相當於除與 5）   \n並把答案加上 6 (因為下面有 6 個數字)   \n\n![](https://github.com/dada878/blog/blob/master/assets/image20240126-2.png?raw=true)\n\n變成這樣   \n可以看到下面的數字剛好就是 6 階乘的子問題   \n\n![](https://github.com/dada878/blog/blob/master/assets/image20240126-3.png?raw=true)\n\n像剛剛的作法一樣   \n把跟 5 無關的數字排除並把它取走一個 5 的質因數   \n答案 += 1\n\n![](https://github.com/dada878/blog/blob/master/assets/image20240126-4.png?raw=true)\n\n這樣就完成 30 階的計算了！   \n   \n根據上面的操作   \n可以推出下列遞迴式   \n\n$$\nf(x) = f(\\lfloor \\frac nx \\rfloor) + \\lfloor \\frac nx \\rfloor\n$$\n不過寫成程式其實用 while 迴圈就可以了   \n```cpp\n#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\nsigned main() {\n    int n;\n    cin >> n;\n    if (n % 2) {\n        cout << 0 << endl;\n        return 0;\n    }\n    int ans = 0;\n    while (n >= 5) {\n        n /= 5;\n        ans += n;\n    }\n    cout << ans << endl;\n}\n```\n",
        "category": "CSES",
        "date": "2024 / 01 / 01"
    },
    {
        "id": "cses-repetitions",
        "title": "題解 CSES Repetitions",
        "content": "# 題解 CSES Repetitions\nhttps://cses.fi/problemset/task/1069\n## 題意\n你有一個由 A、C、G、T 組成的字串 \\\n目標是算出同樣的字母最多連續重複幾次\n## 想法\n把整個字串從左邊往右掃 \\\n用一個 $curLen$ 變數維護目前的長度 \\\n遇到一個字母時 $curLen$ 加 $1$ \\\n如果跟上個字母不同就把 $curLen$ 歸零 \\\n每次掃過一個字母再用 $maxLen$ 維護出現過最大的 $curLen$\n## 程式碼\n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nsigned main() {\n\tchar chr, tmp = 'X';\n\tint maxLen = 1, curLen = 1;\n\twhile (cin >> chr) {\n\t\tif (tmp != 'X' && tmp == chr) {\n\t\t\tcurLen++;\n\t\t} else {\n\t\t\tcurLen = 1;\n\t\t}\n\t\tmaxLen = max(maxLen, curLen);\n\t\ttmp = chr;\n\t}\n\tcout << maxLen << endl;\n}\n```",
        "category": "CSES",
        "date": "2024 / 01 / 01"
    },
    {
        "id": "cses-common-divisors",
        "title": "題解 CSES Common Divisors",
        "content": "# 題解 CSES Common Divisors\nhttps://cses.fi/problemset/task/1081/\n## 題意\n找到兩個數字 \\\n使得兩數的最大公因數盡量大\n## 想法\n可以把題目想成 \\\n找到最大的 x 使得陣列中出現至少兩個他的倍數 \\\n於是我們可以先用 $cnt$ 陣列紀錄每個數字的出現次數 \\\n然後枚舉每個可能的因數 (假設目前枚舉到 k) \\\n從 $k$、$2k$、$3k$ $\\dots$ 計算陣列中存在多少個倍數 \\\n根據[調和級數](./harmonic-series)可以算出時間複雜度為 $O(n \\log n)$\n## 實作\n```cpp\n#include <bits/stdc++.h>\n#define int long long\n\nconst int maxn = 1e6 + 10;\nint cnt[maxn];\n\nsigned main() {\n    int n;\n    cin >> n;\n    vector<int> v(n);\n    for (int i = 0; i < n; i++) {\n        cin >> v[i];\n        cnt[v[i]]++;\n    }\n    for (int k = maxn; k > 0; k--) {\n        int cur = 0;\n        for (int j = k; j < maxn; j += k) {\n            cur += cnt[j];\n        }\n        if (cur >= 2) {\n            cout << k << endl;\n            return 0;\n        }\n    }\n}\n```",
        "category": "CSES",
        "date": "2024 / 01 / 01"
    },
    {
        "id": "cses-weird-algorithm",
        "title": "題解 CSES Weird Algorithm",
        "content": "# 題解 CSES Weird Algorithm\nhttps://cses.fi/problemset/task/1068\n## 題意\n給予一個數字 $n$ \\\n如果他是偶數就把他除 $2$ \\\n否則就把他乘 $3$ 再加 $1$ \\\n重複直到 $n$ 變成 $1$\n## 想法\n沒什麼特別的概念 \\\n直接模擬操作就可以了\n## 程式碼\n```cpp\n#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\nsigned main() {\n\tint n;\n\tcin >> n;\n\twhile(n != 1) {\n\t\tcout << n << \" \";\n\t\tif (n & 1 == 1) {\n\t\t\t n *= 3;\n\t\t\t n++;\n\t\t} else {\n\t\t\tn /= 2;\n\t\t}\n\t}\n\tcout << 1 << endl;\n}\n```",
        "category": "CSES",
        "date": "2024 / 01 / 01"
    },
    {
        "id": "cses-permutations",
        "title": "題解 CSES Permutations",
        "content": "# 題解 CSES Permutations\nhttps://cses.fi/problemset/task/1070/\n## 題意\n給予一個數字 $n$ \\\n你要使用數字 $1 \\sim n$ 構造一個陣列 \\\n使得不存在任意兩個相鄰數字的差為 $1$\n## 想法\n把 $n$ 個數字分成 $1 \\sim \\lfloor \\frac{n}{2} \\rfloor$ 和 $\\lfloor \\frac{n}{2}+1 \\rfloor \\sim n$ 兩堆 \\\n並穿插構造 $ans$ 陣列就可以保證任兩數的差大約為 $\\lfloor\\frac{n}{2}\\rfloor$ \\\n最後跑過整個陣列驗證是否合法即可\n\n![](https://github.com/dada878/blog/blob/master/assets/Snipaste_2023-09-09_21-50-43.png?raw=true)\n## 程式碼\n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nsigned main() {\n\tios_base::sync_with_stdio(false);cin.tie(0);\n\tint n;\n\tcin >> n;\n\tvector<int> arr(n);\n\tdeque<int> ans;\n\tint mid = n/2;\n\tfor (int i = 1; i <= n/2; i ++) {\n\t\tint leftVal = i;\n\t\tint rightVal = mid + i;\n\t\tans.push_back(rightVal);\n\t\tans.push_back(leftVal);\n\t}\n\tif ((n & 1) == 1) {\n\t\tans.push_front(mid + n/2 +1);\n\t}\n\tfor (int i = 0; i < n-1; i++) {\n\t\tif (abs(ans[i+1] - ans[i]) == 1) {\n\t\t\tcout << \"NO SOLUTION\" << endl;\n\t\t\treturn 0 ;\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i ++) {\n\t\tcout << ans[i] << \" \";\n\t}\n\tcout << endl;\n}\n```",
        "category": "CSES",
        "date": "2024 / 01 / 01"
    },
    {
        "id": "apcs-2023-10-solution",
        "title": "APCS 2023 10 月題解",
        "content": "# APCS 2023 10 月題解\n## 前言\n這次 APCS 跟 ISSC 撞期 \\\n然後我就放掉 APCS 跑去打 ISSC : D \\\n下一次要慢三天才能報了 qwq\n## 一、機械鼠\nhttps://zerojudge.tw/ShowProblem?problemid=m370\n### 題意\n數線上有一隻老鼠 \\\n且有 $n$ 個食物散落在數線上 \\\n老鼠可以選擇一直往左或一直往右 \\\n求最多可以吃到幾個食物及最後吃食物的位置\n### 想法\n把問題轉換一下 \\\n就變成是在問老鼠左邊還是右邊食物比較多、最左邊或最右邊的食物在哪裡 \\\n於是只要簡單維護一下就可以幾個變數就可以解出來了\n### 考點\n基本語法\n### 程式碼\n```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nsigned main() {\n    int x, n, tmp;\n    cin >> x >> n;\n    int cntl = 0, cntr = 0; // 左邊與右邊食物數量\n    int maxv = -1e5, minv = 1e5; // 用最大與最小值維護最後停在的食物位置\n    while (n--) {\n        cin >> tmp;\n        if (tmp >= x) cntr++; // 如果食物在左邊\n        if (tmp <= x) cntl++; // 如果食物在右邊\n        maxv = max(maxv, tmp);\n        minv = min(minv, tmp);\n    }\n    if (cntl > cntr) cout << cntl << \" \" << minv << endl; // 往做邊走解更優\n    else cout << cntr << \" \" << maxv << endl; // 否則決定往右邊走\n}\n\n```\n## 二、卡牌遊戲\nhttps://zerojudge.tw/ShowProblem?problemid=m371\n### 題意\n在一個 $n \\times m$ 大小的表格上每格裡都有一張牌 \\\n你可以水平或垂直消除數值為 $x$ 的兩張牌並獲得 $x$ 分，但中間不能有其他牌 \\\n求最多能獲得多少分\n### 想法\n枚舉每張牌，嘗試上或左匹配是否存在相同的牌即可 \\\n使用 $-1$ 紀錄已經匹配掉的牌\n\n至於為什麼只要匹配左上不用考慮右下 \\\n是因為左跟右、還有上跟下是相對關係\n\n我比較在意的地方是 \\\n本來以為這個動作需要重複多次才能匹配所有牌 \\\n結果竟然一次就過了，不知道是不是 ZeroJudge 測資太弱 🤔\\\n或者其實有辦法證明這個作法最多只需要一次\n\n[更新]\\\n關於這個問題，感謝 [M_SQRT 電神的補充](https://zerojudge.tw/ShowThread?postid=38138&reply=0) \\\n確實 Zerojudge 測資有疏失 \\\n已加強程式碼！\n### 考點\n二維陣列、模擬\n### 程式碼\n```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint tb[50][50]; // 表格\n\nsigned main() {\n    int n, m;\n    cin >> n >> m;\n    // 輸入資料\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> tb[i][j];\n        }\n    }\n    int ans = 0;\n    // 重複執行匹配動作至少 n*m 次以配對所有卡牌\n    for (int _ = 0; _ < 1000; _++) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (tb[i][j] == -1) continue;\n                // 嘗試往上配對\n                if (i > 0) {\n                    int k = i-1;\n                    while (k >= 0 && tb[k][j] == -1) k--;\n                    if (tb[i][j] == tb[k][j]) {\n                        // 配對成功\n                        ans += tb[i][j]; // 增加分數\n                        tb[i][j] = tb[k][j] = -1; // 將兩張牌紀錄乘已匹配\n                        continue; // 匹配成功後即可忽略這張牌\n                    }\n                }\n                // 嘗試往左配對\n                if (j > 0) {\n                    int k = j-1;\n                    while (k >= 0 && tb[i][k] == -1) k--;\n                    if (tb[i][j] == tb[i][k]) {\n                        // 配對成功\n                        ans += tb[i][j]; // 增加分數\n                        tb[i][k] = tb[i][j] = -1; // 將兩張牌紀錄乘已匹配\n                        continue; // 匹配成功後即可忽略這張牌\n                    }\n                }\n            }\n        }\n    }\n    cout << ans << endl;\n}\n```\n## 三、搬家\nhttps://zerojudge.tw/ShowProblem?problemid=m372\n### 題意\n一個 $n \\times m$ 的表格上每格有一個水管 \\\n水管分成 $H、I、F、7、L$ 等類型 \\\n每種水管可能連接到上、下、左、右其中某些方向 \\\n求將水管連起來後最大連通塊\n\n*本題詳細題意建議直接進 ZeroJudge 題目頁面查看\n\n### 想法\n簡單來說只要對整張圖做 DFS 並一邊維護連通塊大小即可 \\\n比較麻煩的地方就是建圖而已 \\\n這份程式碼部份參考了 [dreamoon 老師的 code](https://hackmd.io/@aacp/APCS20231022) 才得以把它改得這麼乾淨的 ><\n\n時間複雜度 $O(nm)$\n### 考點\n圖論、DFS / BFS\n### 程式碼\n```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n// 上 右 下 左\nmap<char, vector<int>> mask{\n    {'X', {1,1,1,1}},\n    {'I', {1,0,1,0}},\n    {'H', {0,1,0,1}},\n    {'L', {1,1,0,0}},\n    {'7', {0,0,1,1}},\n    {'F', {0,1,1,0}},\n    {'J', {1,0,0,1}},\n    {'0', {0,0,0,0}},\n};\n\nvector<int> graph[500000]; // 存圖\nbool vis[500000]; // 紀錄造訪過的點\nint ans = 0, cur = 0;\nint n, m;\n\n// 對每座標分配一個 id\nint id (int x, int y) {\n    return x * m + y;\n}\n\n// DFS 並維護連通塊大小\nvoid dfs(int id) {\n    cur++;\n    vis[id] = true;\n    for (auto &u : graph[id]) {\n        if (vis[u]) continue;\n        vis[u] = true;\n        dfs(u);\n    }\n}\n\nsigned main() {\n    cin >> n >> m;\n    vector<string> v(n);\n    for (int i = 0; i < n; i++) cin >> v[i];\n    // 建立整張圖\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            // 上配下\n            if (i + 1 < n && mask[v[i][j]][2] && mask[v[i + 1][j]][0]) {\n                graph[id(i, j)].push_back(id(i + 1, j));\n                graph[id(i + 1, j)].push_back(id(i, j));\n            }\n            // 左配右\n            if (j + 1 < m && mask[v[i][j]][1] && mask[v[i][j + 1]][3]) {\n                graph[id(i, j)].push_back(id(i, j + 1));\n                graph[id(i, j + 1)].push_back(id(i, j));\n            }\n        }\n    }\n    // 對每一個節點做 DFS\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cur = 0;\n            dfs(id(i, j));\n            ans = max(ans, cur); // 嘗試更新答案\n        }\n    }\n    cout << ans << endl;\n}\n```\n## 四、投資遊戲\nhttps://zerojudge.tw/ShowProblem?problemid=m373\n### 題意\n題目~~廢話~~劇情就不多寫了 \\\n簡單來說就是求最大連續子序列合，但可以跳過 $k$ 個元素\n### 想法\n在不考慮 $k$ 的情況下 \\\n這是一個非常經典的問題 \\\n解法的話也非常多元 \\\n以現在這題來說 `Kadane's Algorithm` 應該會是比較好做的\n\n那如果把 $k$ 的條件加進去呢？ \\\n把測資範圍仔細讀過之後可以注意到 $k \\leq 20$ \\\n考慮動態規劃的作法 \\\n我們定義 $dp[i]$ 為考慮陣列前 $i$ 個元素的最佳解 \\\n然後我們可以往前跳過不超過 $k$ 個 \\\n因此 $dp[i]$ 可以從 $dp[i-1]、dp[i-2] \\cdots dp[i-k-1]$ 轉移過來取 $max$ \\\n但我們還需要紀錄總共已經使用了幾個金牌 \\\n所以再開一個維度來維護這個資訊\n\n綜合以上幾點，我們可以推出這樣的轉移式 \\\n定義 $dp[i][j]$ 為考慮前 $i$ 個元素且使用 $j$ 個金牌的最佳解 \\\n轉移的部份 $dp[i][j] = \\max_{1 \\leq l \\leq k}(dp[i-l-1][j-l] + val[i])$\n\n最後照著轉移式把程式寫出來就好ㄌ\n\n時間複雜度 $O(n \\times k^2)$\n\n[更新]\n\n感謝 Colten 提出了 [更好的作法](https://www.facebook.com/groups/359446638362710/posts/1129557418018291?comment_id=1129629131344453) \\\n$dp[i][j]$ 一樣是代表在第 $i$ 天使用 $j$ 個金牌的最佳解 \\\n不過轉移的部份只需要對 $dp[i-1][j-1]$ 和 $dp[i-1][j] + val[i]$ 取 $max$ 就可以 \\\n兩個狀態分別代表在第 $i$ 天使用和不使用金牌 \\\n時間複雜度直接少了一個 $k$ 降到 $O(n \\times k)$ \\\n下面程式碼也用這個寫法實現\n\n然後根據 [吳邦一教授的說法](https://www.facebook.com/groups/359446638362710/posts/1129557418018291?comment_id=1129640624676637) \\\n原本 $O(n \\times k^2)$ 的作法如果使用 Python 的話時間應該不會過\n\n### 考點\n動態規劃\n### 程式碼\n```cpp\n#include <bits/stdc++.h>\n#define int long long\n\nusing namespace std;\n\nint v[200000];\nint dp[200000][30];\n\nsigned main() {\n    int n, k;\n    cin >> n >> k;\n    for (int i = 1; i <= n; i++) { // 第 i 天\n        cin >> v[i]; // 因為只會依賴到之前的狀態所以可以邊讀入邊做\n        for (int j = 0; j <= k; j++) { // 使用 j 個金牌\n            if (j > 0) dp[i][j] = dp[i-1][j-1]; // 使用金牌\n            dp[i][j] = max(dp[i][j], dp[i-1][j] + v[i]); // 不使用金牌\n        }\n    }\n    int ans = 0;\n    // 在所有合法狀態中取得最佳解\n    for (int i = 0; i <= k; i++) {\n        for (int j = 1; j <= n; j++) {\n            ans = max({ans, dp[j][i], 0LL});\n        }\n    }\n    cout << ans << endl;\n}\n```\n## 結語\n整體來說 \\\n這次 APCS 其實不算太難（? \\\n第三題實做比較麻煩一點以外 \\\n最後一題 DP 轉移式也還算好推\n",
        "category": "APCS",
        "date": "2024 / 01 / 01"
    },
    {
        "id": "apcs-tips",
        "title": "APCS 實作滿級完全攻略",
        "content": "# APCS 實作滿級完全攻略\n## 前言\n筆者只是一個滿級的考生 \\\n以下內容都是根據個人經驗給出的建議\n## 考前注意事項\n考試名額不多 \\\n很快就會被搶完 \\\n所以開放報名第一時間記得趕快上去搶\n\n然後第一次應考前一定要先下載[官方的虛擬環境](https://apcs.csie.ntnu.edu.tw/index.php/info/environment/)練習 \\\n並且留意自己習慣的編輯器、IDE 有沒有在環境裡面 \\\n如果沒有的話就要事先練習好其他軟體的操作方式\n## 評分方式\nAPCS 的實作題每次考試總共會有 4 題 \\\n每題 20 筆測資 \\\n每筆測資只要對了就可以獲得 5 分 \\\n所以就算沒辦法拿滿分 \\\n寫多少算多少 \\\n一定要傳上去\n## 實作第 2 級\n### 出題範圍\n- 基本程式語法\n### 練習方式\n如果只是要拿二級的話 \\\n其實練習方式還蠻廣的 \\\n基本上所有\"會寫程式的人\"都可以達到這個等級 \\\n也就是說 \\\n不管你想去寫網頁、開發遊戲、刷題目都應該可以達到 2 級這個目標\n## 實作第 3 級\n### 出題範圍\n- 二維陣列\n- 複雜模擬\n### 練習方式\nAPCS 的 3 級範圍非常吃實作能力 \\\n需要邏輯清晰且可以處理複雜的操作才能達到 3 級 \\\n一個比較複雜的例子：[APCS 2022/10 貨運站](https://zerojudge.tw/ShowProblem?problemid=j123) \\\n而且在第二題當中 \\\n二維陣列操作出現的的頻率非常高 \\\n必須非常熟悉二維陣列 \\\n最後建議想達到 3 級分的話可以多練歷屆 APCS 第二題\n\n不過如果你的目標是更高的級分 \\\n其實不需要刷太多歷屆第二題 \\\n通常隨著能力提升實作能力也會自然提升\n## 實作第 4 ~ 5 級\n### 出題範圍\n- 排序\n- 搜尋\n- 貪心\n- 遞迴\n- 動態規劃\n- 資料結構\n### 練習方式\n4 級跟 5 級的範圍其實差不多 \\\n不過最大的差別就是要拿到 4 級只需要知道比較淺的知識就行了 \\\n那想達到 4/5 級的話就非常吃演算法和資料結構的運用能力 \\\n非常推薦這份 [AP325 講義](https://drive.google.com/drive/u/0/folders/10hZCMHH0YgsfguVZCHU7EYiG8qJE5f-m)\n\n題目的部分 \\\n很常出現經典題或者經典題稍微改編 \\\n所以也很建議去 [CSES](https://cses.fi) 這個很多經典題的 Judge 多刷點題 \\\n可以配合 [CSES 寶典](https://cses.fi/book.pdf) 一起讀\n## 更多的練習\n集結了多位 APCS 滿級分的出題者與驗題者 \\\n我們在每個月都會辦一場 APCS 模擬賽 \\\n如果還不清楚自己練習方向或想測試實力的話 \\\n歡迎加入 [Discord 群組](https://discord.gg/RnhATqeMtd)參與模擬賽 \\\n重點是完全免費！！",
        "category": "APCS",
        "date": "2024 / 01 / 01"
    },
    {
        "id": "cf918-div-4",
        "title": "Codeforces 918 Div 4 題解",
        "content": "# Codeforces 918 Div 4 題解\n## 前言\n為了慶祝第一次在 CF 破台所以難得來寫一下題解 \\\n這成績我可以開心一個禮拜了 :> \\\n~~然後今天早上過的太廢一題都沒寫不知道是不是因為這樣把能量都留到這場釋放了~~\n![](https://github.com/dada878/blog/blob/master/assets/2023-12-29-01-57-27.png?raw=true)\n## pA - Odd One Out\n### 題意\n給定三個數，其中兩個數相同，找到不同的那一個數\n### 思路\n直接照題意模擬做就行了，實作的部分用 map 很方便\n### 程式碼\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n \nint main() {\n    int t, tmp;\n    cin >> t;\n    while (t--) {\n        map<int, int> cnt;\n        // 計算每個數字出現幾次\n        for (int i = 1; i <= 3; i++) {\n            cin >> tmp;\n            cnt[tmp]++;\n        }\n        // 找到出現次數為 1 的那個數\n        for (auto [num, frq] : cnt) {\n            if (frq == 1) cout << num << endl;\n        }\n    }\n}\n```\n## pB - Not Quite Latin Square\n### 題意\n給予一個 3x3 的矩陣，每行、列都剛好包含各一個 A、B、C 字母，但某一格未知，任務是找到未知的那格是什麼\n### 思路\n直接照題意模擬做就行了，實作的部分用 set 很方便\n### 程式碼\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nchar tb[5][5];\n\n// 檢查矩陣是否合法\nbool check() {\n    // 檢查每個 row\n    for (int i = 0; i < 3; i++) {\n        set<char> st;\n        for (int j = 0; j < 3; j++) {\n            st.insert(tb[i][j]);\n        }\n        if (st.size() != 3) return false;\n    }\n    // 檢查每個 column\n    for (int i = 0; i < 3; i++) {\n        set<char> st;\n        for (int j = 0; j < 3; j++) {\n            st.insert(tb[j][i]);\n        }\n        if (st.size() != 3) return false;\n    }\n    return true;\n}\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int px, py; // 未知格的座標\n        for (int i = 0; i < 3; i++) {\n            for (int j = 0; j < 3; j++) {\n                cin >> tb[i][j];\n                if (tb[i][j] == '?') {\n                    px = i;\n                    py = j;\n                }\n            }\n        }\n        // 枚舉該放哪個字母\n        for (char c = 'A'; c <= 'C'; c++) {\n            tb[px][py] = c;\n            // 如果合法就輸出\n            if (check()) {\n                cout << c << endl;\n            }\n        }\n    }\n}\n```\n## pC - Can I Square?\n### 題意\n有 $n$ 個盒子，第 $i$ 個盒子裝著 $a_i$ 個 1x1 的紙片，求是否可以剛好用所有的紙片拼成一個平片的正方形？\n### 思路\n事實上題目問的就只是 $\\sum_{i=1}^n a_i$ 是否為完全平方數 \\\n所以只需要加總後開根在平方看是否跟原始的數相等就行了\n### 程式碼\n```cpp\n#include <bits/stdc++.h>\n#define int long long\n#define square(x) ((x)*(x))\nusing namespace std;\n\nsigned main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int n, tmp, sum = 0;\n        cin >> n;\n        for (int i = 0; i < n; i++) {\n            cin >> tmp;\n            sum += tmp;\n        }\n        if (square((int)sqrt(sum)) == sum) {\n            cout << \"YES\" << endl;\n        } else {\n            cout << \"NO\" << endl;\n        }\n    }\n}\n```\n## pD - Unnatural Language Processing\n### 題意\n有一種只包含 a、b、c、d、e 的語言，這些字母被分成兩種類型\n- Vowels — 包含字母 a 和 e，用 V 表示\n- Consonants — 包含字母 b、c、d，用 C 表示\n\n一個合法的段落可能為 CV 或 CVC \\\n給予一串文字 \\\n求將它按照規則分段的結果\n### 思路\n直接隨便取的話會出一些問題 \\\n不過其實只需要觀察到兩個 C 不能連再一起就完事了 \\\n雖然我也還沒完整的證過 (因為我不是數學家)\n### 程式碼\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n// 儲存每個字母是 v 或 c 類\nmap<char, char> tb = {\n    {'a', 'v'},\n    {'b', 'c'},\n    {'c', 'c'},\n    {'d', 'c'},\n    {'e', 'v'},\n};\n\nvoid sol() {\n    int n;\n    string s; // 題目給的字串\n    string ss; // 轉換過後只包含 c 跟 v 的字串\n    cin >> n >> s;\n    // 轉換字串\n    for (auto c : s) ss += tb[c];\n    // 分段後的結果\n    vector<string> ans;\n    for (int i = 0; i < s.size(); ) {\n        if (i == s.size() - 3) { // 只剩下最後三個字就直接全取\n            ans.push_back(s.substr(i, 3));\n            break;\n        }\n        if (ss[i+3] == ss[i+2] && ss[i+2] == 'c') {\n            // 如果選 CV 會導致兩個連續 C 的情況出現就改選 CVC\n            ans.push_back(s.substr(i, 3));\n            i = i + 3;\n        } else {\n            // 否則就選 CV\n            ans.push_back(s.substr(i, 2));\n            i = i + 2;\n        }\n    }    \n    // 輸出解\n    for (int i = 0; i < ans.size(); i++) {\n        if (i != 0) cout << \".\";\n        cout << ans[i];\n    }\n    cout << endl;\n}\n \nint main() {\n    int t;\n    cin >> t;\n    while (t--) sol();\n}\n```\n## pE - Romantic Glasses\n### 題意\n給定一個陣列，求是否存在一段連續的區間滿足偶數 index 的所有元素加起來等於奇數 index 的元素\n### 思路\n把偶數 index 的元素都加上負號再套上前綴和之後 \\\n題目就被轉換成找到一個區間滿足總和為 0\n\n也就是說只要從左掃到右 \\\n並對於每個位置檢查左邊是否存在相同值的元素即可\n### 程式碼\n```cpp\n#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n \nvoid sol() {\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n        if (i % 2 == 0) a[i] *= -1;\n    }\n    vector<int> psum(n + 1);\n    partial_sum(a.begin(), a.end(), psum.begin() + 1);\n    set<int> st;\n    for (auto e : psum) {\n        if (st.find(e) != st.end()) {\n            cout << \"YES\" << endl;\n            return;\n        }\n        st.insert(e);\n    }\n    cout << \"NO\" << endl;\n}\n \nsigned main() {\n    int t;\n    cin >> t;\n    while (t--) sol();\n}\n```\n## pF - Greetings\n### 題意\n有 $n$ 個人在數線上以每秒 1 格的速度往右走，第 $i$ 個人的起點為 $a_i$ 終點為 $b_i$，求他們倆倆碰面（同時出現在同一格）的次數\n### 思路\n仔細觀察之後會發現 \\\n只有 $a_i$ > $a_j$ 且 $b_i$ < $b_j$ 的情況下 $i$ 跟 $j$ 才會碰面 \\\n(也就是一個區間把另外一個區間包住的情況)\n\n可以發現其實就跟 CSES 的 [Nested Ranges Count](https://cses.fi/problemset/task/2169) 完全一樣 \\\n那這題網路上題解很多 \\\n算法細節就不多提了\n### 程式碼\n```cpp\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#define int long long\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\ntemplate <class T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\nvoid sol() {\n    int n;\n    cin >> n;\n    vector<int> becon(n), yidx(n);\n    vector<tuple<int, int, int>> b(n), c(n);\n \n    for (int i = 0; i < n; ++i) {\n\t\tint l, r;\n\t\tcin >> l >> r;\n        b[i] = {l, r * -1, i};\n        c[i] = {r, l * -1, i};\n    }\n \n    sort(b.begin(), b.end());\n    sort(c.begin(), c.end());\n    \n\tfor (int i = 0; i < n; ++i)\n        yidx[get<2>(b[i])] = i;\n \n    ordered_set<int> s;\n    \n    for (int i = 0; i < n; ++i) {\n        int idx = get<2>(c[i]);\n        int cur = yidx[idx];\n        becon[idx] = s.size() - s.order_of_key(cur);\n        s.insert(cur);\n    }\n \n    int ans = 0;\n    for (int i = 0; i < n; ++i) ans += becon[i];\n    cout << ans << endl;\n}\n \nsigned main() {\n    io;\n    int t;\n    cin >> t;\n    while (t--) sol();\n}\n```\n## pG - Bicycles\n### 題意\n給一張無向帶權圖，第 $i$ 條邊連接著 $v_i$ 及 $u_i$ 且權重為 $w_i$，你可以在節點 $i$ 拿到一台速度為 $s_i$ 的腳踏車，騎著速度為 $s_i$ 的腳踏車經過第 $j$ 條邊時需要花費 $s_i \\times w_j$，求全程騎腳踏車從 $1$ 走到 $n$ 的最少時間花費\n### 思路\n不難想到從點 $v$ 獲得腳踏車後到其他每個點 $u$ 的最少時間花費為 $dist(v, u) * s_v$ (其中 $dist$ 代表兩點最短路徑長度) \\\n那其實就只要依照上面的規則把那些邊都建在新的圖上 \\\n最後對新的圖做最短路就可以了\n\n補充資料: [最短路演算法](https://dada878.com/blogs/graph-shortest-path)\n```cpp\n#include <bits/stdc++.h>\n#define int long long\n#define pii pair<int, int>\n#define ff first\n#define ss second\n\nusing namespace std;\n\nconst int maxn = 1e3 + 10;\nconst int inf = 1e13;\n \nint n, m;\nvector<pii> g[maxn];\nint bike[maxn];\n \nvector<pii> g2[maxn];\nint dist2[maxn][maxn];\n \nint dist[maxn];\n \nvoid sol() {\n    // 初始化 & 讀取輸入\n    cin >> n >> m;\n    for (int i = 0; i <= n; i++) {\n        for (int j = 0; j <= n; j++) {\n            dist2[i][j] = inf;\n        }\n    }\n    for (int i = 0; i <= n; i++) {\n        g[i].clear();\n        g2[i].clear();\n    }\n    for (int i = 0; i < m; i++) {\n        int a, b, w;\n        cin >> a >> b >> w;\n        g[a].push_back({b, w});\n        g[b].push_back({a, w});\n    }\n    for (int i = 1; i <= n; i++) {\n        cin >> bike[i];\n    }\n    // 在原始的圖上求每個點對得最短路\n    for (int v = 1; v <= n; v++) {\n        // 初始化\n        for (int i = 1; i <= n; i++) {\n            dist[i] = inf;\n        }\n        // 使用 dijkstra 演算法\n        priority_queue<pii, vector<pii>, greater<pii>> pq;\n        pq.push({0, v});\n        dist[v] = 0;\n        while (pq.size()) {\n            auto now = pq.top(); pq.pop();\n            if (now.ff > dist[now.ss]) continue;\n            for (auto other : g[now.ss]) {\n                if (dist[other.ff] > dist[now.ss] + other.ss) {\n                    dist[other.ff] = dist[now.ss] + other.ss;\n                    pq.push({dist[other.ff], other.ff});\n                }\n            }\n        }\n        // 建邊在新的圖上\n        for (int i = 1; i <= n; i++) {\n            if (i == v) continue;\n            g2[v].push_back({i, dist[i] * bike[v]});\n        }\n    }\n    // 初始化 (準備在新的圖上做最短路)\n    for (int i = 1; i <= n; i++) {\n        dist[i] = inf;\n    }\n    // 使用 dijkstra 演算法\n    priority_queue<pii, vector<pii>, greater<pii>> pq;\n    pq.push({0, 1});\n    dist[1] = 0;\n    while (pq.size()) {\n        auto now = pq.top(); pq.pop();\n        if (now.ff > dist[now.ss]) continue;\n        for (auto other : g2[now.ss]) {\n            if (dist[other.ff] > dist[now.ss] + other.ss) {\n                dist[other.ff] = dist[now.ss] + other.ss;\n                pq.push({dist[other.ff], other.ff});\n            }\n        }\n    }\n    // 輸出解\n    cout << dist[n] << endl;\n}\n \nsigned main() {\n    int t;\n    cin >> t;\n    while (t--) sol();\n}\n```",
        "category": "Codeforces",
        "date": "2024 / 01 / 01"
    },
    {
        "id": "awesome-book-list",
        "title": "個人推薦書籍列表",
        "content": "# 個人推薦書籍列表\n這份清單會持續更新喔 ><\n<table>\n  <tr>\n    <th>封面</th>\n    <th>書名</th>\n    <th>簡介</th>\n    <th>評價</th>\n  </tr>\n  <tr>\n    <td><img src=\"https://cdn.readmoo.com/cover/fg/8einmi9_460x580.jpg?v=1635911435\" width=300></td>\n    <td>原子習慣</td>\n    <td>本書介紹了習慣的強大力量，且提出了多個有別於傳統框架的習慣養成法</td>\n    <td>從早上起床到夜晚入睡，人類生活中很大部分的一切都受習慣所控制。我從沒想過，習慣竟然強大到是足以改變人的一生。以前我們總是被教導著，養成一個好習慣就是要靠強大的意志力，看完之後才知道，原來那些我們認為意志力很強大的人，往往是最少用到意志力的</td>\n  </tr>\n  <tr>\n    <td><img src=\"https://github.com/dada878/blog/assets/37009584/4133601a-e834-493a-8d0a-85903b030b02\" width=300></td>\n    <td>六分鐘日記的魔法</td>\n    <td>以正向心理學、習慣、自我反省等多種理論研究構成，一本通往快樂、更充實人生的日記</td>\n    <td>待補</td>\n  </tr>\n</table>\n",
        "category": "Other",
        "date": "2024 / 01 / 01"
    },
    {
        "id": "cpp-stl",
        "title": "C++ 常見 STL 教學",
        "content": "# C++ 常見 STL 教學\n## piar\n### 簡介\npair 是一種可以儲存兩個元素的資料結構\n### 用途\n通常用來儲存二維座標或者是陣列的 index 與 value \\\n而且常數較小 \\\n如果用 `array / vector` 替代有些題目真的會被卡 TLE\n### 語法\n```cpp\n// 宣告一個第一個欄位為 1 第二個欄位為 5 的 pair\n// 在一些 c++ 版本較舊的環境下要使用 make_pair(1, 5)\npair<int, int> pos = {1, 5};\n\n// 取得第一個欄位的值\ncout << pos.first << endl;\n\n// 取得第二個欄位的值\ncout << pos.second << endl;\n\n// 將 pos 的第一個欄位的 1 改成 2\npos.first = 2;\n\n// 將 pos 的第二個欄位的 5 改成 4\npos.second = 4;\n```\n### 比較\n在比較兩個 pair 時會先比第一個元素 \\\n如果第一個元素相同才會比第二個元素\n## vector\n### 簡介\n跟傳統陣列差不多 \\\n不過長度是可變的 \\\n會因為加入更多元素讓 vector 變得更長\n### 用途\n不用多說了吧 \\\n就是可以像陣列一樣儲存 n 個元素\n### 語法\n```cpp\n// 直接宣告 vector 的方式\nvector<int> v1;\n\n// 宣告長度為 n 的 vector\nvector<int> v2(n);\n\n// 宣告長度為 n 且每個元素都是 5 的 vector\nvector<int> v3(n, 5);\n\n// 宣告一個有元素 {1, 2, 3, 4} 的 vector\nvector<int> v4 = {1, 2, 3, 4}\n\n// 宣告一個跟其他 vector 一樣的 vector (複製)\nvector<int> v5(v4);\n\n// 加入元素在尾端\nv1.push_back(7);\n\n// 從尾端移除元素\nv1.pop_back();\n\n// 存取 vector 中的某一項\ncout << v4[2] << endl;\n\n// 取得大小\ncout << v2.size() << endl;\n```\n### 比較\n從第一個元素開始比較 \\\n如果相同就繼續往後比 \\\n直到第一個不同為止\n## queue\n### 簡介\n像是一個排隊的隊伍 \\\n可以從一端進入 \\\n從另一端離開 \\\n也就是先進去的會先離開\n### 用途\n大部分情況用來實作一些較複雜的演算法 \\\n比如 BFS、拓撲排序等等\n### 語法\n```cpp\n// 宣告一個 queue\nqueue<int> q;\n\n// 將元素 5 推入 queue 後端\nq.push(5);\n\n// 取得 queue 前端的元素\ncout << q.front() << endl;\n\n// 取得 queue 後端的元素\ncout << q.back() << endl;\n\n// 將隊伍前端的元素彈出(移除)\nq.pop();\n\n// 檢查 queue 是否為空\nif (q.empty()) {\n    cout << \"empty\" << endl;\n}\n\n// 取得 queue 的大小\ncout << q.size() << endl;\n\n```\n## stack\n### 簡介\n類似於一疊盤子 \\\n最後放上去的盤子會最先被取走 \\\n而你不能從中間拿走盤子 \\\n也就是說後進去的會先出去\n### 用途\nstack 常用來會處理一些匹配類問題 \\\n或者是模擬遞迴 \\\n更進階一點還有單調堆疊之類的玩法\n### 語法\n```cpp\n// 宣告一個 stack\nstack<int> stk;\n\n// 將元素 3 推入 stack\nstk.push(3);\n\n// 從 stack 頂端取出元素\ncout << stk.top() << endl;\n\n// 將 stack 頂端的元素彈出(移除)\nstk.pop();\n\n// 檢查 stack 是否為空\nif (stk.empty()) {\n    cout << \"empty\" << endl;\n}\n\n// 取得 stack 的大小\ncout << stk.size() << endl;\n```\n## set\n### 簡介\n就是集合的意思 \\\n用來儲存不重複的元素 \\\n並會按照元素的大小自動排序\n### 用途\n主要用於快速插入和查找元素\n### 語法\n```cpp\n// 宣告一個 set\nset<int> st;\n\n// 插入元素\nst.insert(5);\nst.insert(3);\nst.insert(7);\n\n// 檢查 set 是否包含某元素\nif (st.find(3) != st.end()) {\n    cout << \"set contains 3\" << endl;\n} else {\n    cout << \"set does not contain 3\" << endl;\n}\n\n// 刪除元素\nst.erase(5);\n\n// 遍歷 set 中的元素\nfor (int e : st) {\n    cout << e << \" \";\n}\n\n// 取得 set 的大小\ncout << st.size() << endl;\n\n// 取得 set 的第一項\n// 因為回傳的是 iterator 所以要加 *\ncout << *st.begin() << endl;\n\n// 取得 set 的最後一項\n// 由於 back 是開區間所以要 -1\ncout << *--st.end() << endl;\n```\n## map\n### 簡介\n語法根陣列有點像 \\\n不過可以接受整數以外的型態來當作索引值\n### 用途\n有些時候需要使用負數、非常大的數字、字串等等來當索引值 \\\nmap 就會是一個很方便的工具\n### 語法\n```cpp\n// 宣告一個以 string 為索引，int 為值的 map\nmap<string, int> mp;\n\n// 把字串對應到數字\nmp[\"one\"] = 1;\nmp[\"two\"] = 2;\nmp[\"three\"] = 3;\n\n// 輸出 one 的值\ncout << mp[\"one\"] << endl;\n\n// 在 map 中刪除 one\nmp.erase(\"one\");\n\n// 遍歷 map\nfor (auto [key, value] : mp) {\n    cout << key << \", \" << value << endl;\n}\n\n// 取得 map 的大小\ncout << mp.size() << endl;\n```\n## priority queue\n### 簡介\n又稱為 heap \\\n可以支援快速地插入及查詢最大最小值\n### 用途\n很常使用在一些複雜的演算法內 \\\n比如最短路徑、最小生成樹等等\n### 語法\n```cpp\n// 宣告一個 priority queue\npriority_queue<int> pq;\n\n// 宣告一個 priority queue 並且頂部為最小值\npriority_queue<int, vector<int>, greater<int>> pq;\n\n// 插入元素\npq.push(3);\npq.push(1);\npq.push(5);\n\n// 取得頂端的元素(最大值)\ncout << pq.top() << endl;\n\n// 移除頂端的元素\npq.pop();\n\n// 檢查 priority queue 是否為空\nif (pq.empty()) {\n    cout << \"empty\" << endl;\n}\n\n// 取得 priority queue 的大小\ncout << pq.size() << endl;\n```",
        "category": "Algorithms",
        "date": "2024 / 01 / 01"
    },
    {
        "id": "graph-shortest-path",
        "title": "很多最短路演算法",
        "content": "# 很多最短路演算法\n## Dijkstra\n### 概念\n每次選擇最近的節點 \\\n嘗試透過該節點來更新相鄰節點距離\n### 實作\n將所有節點距離初始化為 $\\infty$ ( 起點為 0 ) \\\n選擇目前距離起點最近的節點 \\\n如果目前節點距離加上相鄰節點與目前節點距離小於起點到相鄰節點的距離就更新\n### 程式碼\n```cpp\nfor (int i = 1; i <= n; i++) distance[i] = INF;\ndistance[x] = 0;\nq.push({0, x});\nwhile (!q.empty()) {\n\tint a = q.top().second; q.pop();\n    // 絕對不會更新到的話直接 continue 掉\n    if (a.first > dist[now.second]) continue;\n\tfor (auto u : adj[a]) {\n\t\tint b = u.first, w = u.second;\n\t\tif (distance[a] + w < distance[b]) {\n\t\t\tdistance[b] = distance[a] + w;\n            // 因為要讓距離小的排在前面所以加負號\n\t\t\tq.push({-distance[b], b});\n\t\t}\n\t}\n}\n```\n## Floyd-WarShall\n### 概念\n這個演算法是由某個 DP 概念延伸出來的 \\\n最初的轉移式大概長這樣\n\n定義:\n\n> $dp[k][i][j]$ 為 $i$ 到 $j$ 的最短距離，且只能經過額外的 $k$ 個點\n\n轉移式:\n\n> $\\mathrm {dp} (i,j,k)=\\mathrm {min} {\\Big (}\\mathrm {dp} (i,j,k-1),\\mathrm {dp} (i,k,k-1)+\\mathrm {dp} (k,j,k-1){\\Big )}$\n\n### 實作\n依照 DP 轉移式枚舉每個點做轉移就好了 \\\n實作上由於 k 是按照順序轉移的所以可以把空間壓到二維 \\\n記得要注意迴圈是由外而內順序是 $k$、$i$、$j$ \n\n### 程式碼\n```cpp\nfor (int k = 1; k <= n; k++) {\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\tdist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\t\t}\n\t}\n}\n```\n### 奇怪的小技巧\n如果不小心忘記寫成 $i$ $j$ $k$ 的話只要做三次就會對了 \\\n2019 年的某篇論文上提到了這點\n\n![](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fd477b2f1-0d39-4fe4-a359-31eac3004e02%2FUntitled.png?table=block&id=033abae1-3cc2-443d-ab3a-59a5b6e68366&spaceId=090471c9-4258-4339-8654-7be181344180&width=1720&userId=72aeb5d8-6609-42c6-8c49-344fc9073da7&cache=v2)\n\n### 判斷負環\n如果任一個 $dist[i][i] < 0$ 若且唯若存在負環 \\\n代表有一個點自己繞一圈回到自己距離小於 0 \\\n但如果是無向圖的話的負環就很難判斷了\n\n## Bellman-Ford\n### 概念\n對於每個邊嘗試更新連接的兩個點對於起點的距離\n### 實作\n重複 n-1 次嘗試更新所有的邊\n### 程式碼\n```cpp\nfor (int i = 1; i <= n; i++) dist[i] = INF;\n\tdist[x] = 0;\n\tfor (int i = 1; i <= n-1; i++) {\n\t\tfor (auto e : edges) {\n\t\t\tint a, b, w;\n\t\t\ttie(a, b, w) = e;\n\t\t\tdist[b] = min(dist[b], dist[a] + w);\n\t\t}\n\t}\n}\n```\n### 判斷負環\n如果更新了 n-1 次還能繼續更新 \\\n代表這張圖存在負環\n## 結論\n看完這些之後 \\\n想必一定有人會覺得「為什麼要學這麼多種最短路演算法」 \\\n原因很簡單，因為這些演算法各自有不同的特性與效率 \\\n所以需要適時挑選適合的演算法來使用\n\n不過比較值得注意的是 \\\n事實上如果要求多源最短路的話 \\\n枚舉每個點做 Dijkstra 甚至比 Floyd-Warshall 還快\n\n|  | Bellman-Ford | Dijkstra | Floyd-Warshall |\n| --- | --- | --- | --- |\n| 類型 |  單點源 | 單點源 | 全點對 |\n| 限制 | 任意圖 | 無負邊 | 任意圖 |\n| 時間複雜度 | $O(VE)$ | $O(E log E)$ | $O(V^3)$ |\n| 用途 | 檢查負環 | 快速單點源 | 負邊全點對 |\n",
        "category": "Algorithms",
        "date": "2024 / 01 / 01"
    },
    {
        "id": "graph-introduction",
        "title": "圖論入門",
        "content": "# 圖論入門\n## 什麼是圖\n首先 \\\n我們要先來了解什麼是圖\n\n簡單來說 \\\n圖 (Graph) 就是由多個節點 (Node) 並透過邊 (Edge) 連結成的我們\n像是下面的示意圖\n\n![](https://github.com/dada878/blog/blob/master/assets/image-20240128-1.png?raw=true)\n\n## 建立一張圖\n在知道圖是什麼之後 \\\n我們要來看的是如何在 C++ 中儲存一張圖\n\n在大部分的情況下 \\\n我們會以節點關係來儲存一張圖\n\n像是上面那張圖片的範例 \\\n我們知道節點 1 會連接到節點 2 跟 3 \\\n節點 2 會連接到節點 1 跟 3 \\\n節點 3 會連接到節點 2 跟 4 \\\n節點 4 會連接到節點 3 跟 5 \\\n節點 5 會連接到節點 4 \n\n也就是說 \\\n我們實際上要存的資料大概長這樣：\n```\n1 -> [2, 3]\n2 -> [1, 3]\n3 -> [2, 4]\n4 -> [3, 5]\n5 -> [4]\n```\nC++ 內可以使用傳統陣列套 vector 來實現\n```cpp\n// MAXN 最大節點數量\nvector<int> graph[MAXN];\n\n// 下面的操作就是相當於我們從節點 1 建立了兩條邊分別指向 2 跟 3\ngraph[1].push_back(2);\ngraph[1].push_back(3);\n```\n## 拜訪圖上的節點\n在很多的情境下 \\\n我們會需要拜訪整張圖上面的所有節點來得知一些資訊\n\n這邊會簡單的介紹一下 DFS (深度優先搜尋) 演算法的作法 \\\n這個演算法就是利用遞迴的特性遍歷整張圖\n\n這個演算法會儘可能深的搜尋圖的分支 \\\n當節點的所有邊都已經被搜尋過 \\\n則會回溯到上個節點 \\\n這個過程會一直重複到搜尋完整張圖為止\n\n![](https://github.com/dada878/blog/blob/master/assets/image-20240128-5.png?raw=true)\n\n程式碼應該不難理解 \\\n直截來看看吧：\n\n```cpp\nvector<int> graph[MAXN]; // 存圖\nbool vis[MAXN]; // 紀錄哪些節點拜訪過\n\nvoid dfs(int v) {\n    // 枚舉每一個 v 可以走到的節點\n    for (int u : graph[v]) {\n        // 如果走過就略過\n        if (vis[u]) continue;\n        // 標記為走過\n        vis[u] = true;\n        // 造放進節點 u\n        dfs(u);\n    }\n}\n```\n## 樹狀圖\n樹其實就是圖的一種 \\\n有一些特性：\n- 不存在環\n- 每個節點均可以走到其他每個節點\n- 若有 $n$ 個節點，邊就是 $n-1$ 條\n\n這邊先補充一下 \\\n環就是指像是最上面的示意圖 1 -> 2 -> 3 那部分的結構\n\n然後樹的其他部分都跟圖差不多 \\\n不過 DFS 可以寫的比圖簡單\n```cpp\nvoid dfs(int v, int p) {\n    // 枚舉每一個 v 可以走到的節點\n    for (int u : graph[v]) {\n        // 不能走回上個節點\n        if (u == p) continue;\n        // 造放進節點 u\n        dfs(u, v);\n    }\n}\n```\n## 練習\n這裡是一些簡單的練習題：\n- [CSES \nBuilding Roads](https://cses.fi/problemset/task/1666)\n- [CSES Message Route](https://cses.fi/problemset/task/1667)\n## 延伸閱讀\n或者你也可以在這邊了解一些更進階的內容：\n- [最短路演算法](https://dada878.com/blogs/graph-shortest-path)\n",
        "category": "Algorithms",
        "date": "2024 / 01 / 01"
    },
    {
        "id": "tioj-2195",
        "title": "[題解] TIOJ 2195 粉刷護欄 (TOI 2021 初選 pC)",
        "content": "# [題解] TIOJ 2195 粉刷護欄 (TOI 2021 初選 pC)\n## 題意\n上下有個有一根木樑 \\\n然後中間有 n 條可能會相交的木板 \\\n找出最多可以釘上幾條木板並構造最大字典序的解 \\\n(細節自己去 TIOJ 看 :<)\n## 前言的部分\n因為這題看起來沒人寫題解 \\\n於是我就發了這篇文章 ouob\n## 轉化問題\n仔細觀察問題 \\\n我們可以把問題轉換成 LIS 或 LCS\n\nLCS 的話應該不難理解 \\\n因為要釘最多木板其實就是要在上下兩條陣列各選一個共同的子序列 \\\n然後把每個數字一一對應釘起來 \\\n但是 LCS 需要 $O(n^2)$ 的時間複雜度才能計算 \\\n所以一定會 TLE\n\n接著是 LIS 的作法 \\\n仔細觀察題目的話可以發現 \\\n如果木板有\"座標\"的話 \\\n其實我們在做的事情就是\"對木板做 LIS\" \\\n更精確一點的說 \\\n就是我們其實可以把木板在上樑的點跟下樑的點綁成一個 pair 做 LIS \\\n我們說木板 A 的座標小於木板 B 代表 A 的下樑座標跟上樑座標都小於 B\n\n至於座標的部分大概就是這個意思： \\\n以附圖為例 \\\n木板 3 的座標就是 (2, 1) \\\n木板 4 的座標就是 (5, 3) \\\n木板 5 的座標就是 (4, 4)\n\n![](https://github.com/dada878/blog/blob/master/assets/20240208.png?raw=true)\n## 如何構造解\n如果用最普通的 DP 方式 \\\n就算能構造解也很難求最大字典序 \\\n於是我們修改一下計算方式 \\\n把轉移式改成 \"定義 $dp[i]$ 為把第 $i$ 個元當頭素能構造出的 LIS\" \\\n其實就只是倒著做 LIS 然後 Increasing 改成 Decreasing 就好了\n\n做完 DP 之後 \\\n我們要從 dp 值大的開始構造 \\\n先找一個 dp 值跟最終 LIS 一樣長而且字典序最大的元素 \\\n接著往右找小一點的直到 1 為止\n## 實作細節\n關於上面提到的\"座標\" \\\n實際上不需要真的把座標算出來 \\\n我們只需要把第二個陣列(代表下梁座標的陣列)每一個元素替換成該元素在第一個陣列出現的位置 \\\n並對第二個陣列做 LIS 就可以了 \\\n~~原因的話講起來有點麻煩 自己想吧~~\n## 一個小測資\n第一次傳 WA 了一片 \\\n然後 debug 的時後測出這樣的測資會出錯 \\\n如果你也找不到你的程式坐在哪裡的話 \\\n不仿測試看看這筆測資\n```\n3\n3 1 2\n1 2 3\n```\n## 最後的程式碼\n```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define all(x) x.begin(), x.end()\n#define io ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\nconst int MAXN = 2e5 + 10;\n\n// map 會超時，所以改 unordered_map\nunordered_map<int, int> rpos;\nunordered_map<int, int> pos;\nvector<int> lens[MAXN];\nint v[MAXN];\n\nbool cmp(int a, int b) {\n    return rpos[v[a]] > rpos[v[b]];\n}\n\nsigned main() {\n    io;\n    int n;\n    cin >> n;\n    for (int i = 1; i <= n; i++) {\n        int tmp;\n        cin >> tmp;\n        // 紀錄元素座標\n        pos[tmp] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        int tmp;\n        cin >> tmp;\n        // 將陣列的值設定為目前元素在上面陣列的出現位置\n        v[i] = pos[tmp];\n        // 把坐標在映射回他的值，輸出的時候會用到\n        rpos[pos[tmp]] = tmp;\n    }\n    // LIS 的部分\n    // 作法類似：https://usaco.guide/gold/lis?lang=cpp\n    int len = 0;\n    vector<int> dp;\n    for (int i = n; i >= 1; i--) {\n        int ans = 0; // 儲存目前 dp 值：以 i 為開頭能構造出多長的 LIS\n        if (dp.empty() || dp.back() > v[i]) {\n            dp.push_back(v[i]);\n            // 紀錄目前的 dp 值\n            ans = dp.size();\n        } else {\n            auto ite = upper_bound(all(dp), v[i], greater<int>());\n            *ite = v[i];\n            // 紀錄目前的 dp 值\n            ans = ite - dp.begin() + 1;\n        }\n        // len 維護最終 LIS 長度\n        len = max(len, ans);\n        // 紀錄每個長度的解\n        lens[ans].push_back(i);\n    }\n    // 構造解\n    int cur = 0;\n    for (int i = len; i >= 1; i--) {\n        // 依照字典序做 sort\n        sort(all(lens[i]), cmp);\n        for (auto j : lens[i]) {\n            // 排除在目前選到的元素左邊的元素\n            if (j <= cur) continue;\n            // 排除加入後會相交的元素 (用於排除文章中寫的“一個小測資”那段的 Case)\n            if (v[j] < v[cur]) continue;\n            cur = j;\n            // 把 index 映射回去並輸出\n            cout << rpos[v[j]] << \" \";\n            break;\n        }\n    }\n}\n```\n",
        "category": "TIOJ",
        "date": "2024 / 01 / 01"
    },
    {
        "id": "tioj-2173",
        "title": "[題解] TIOJ 2173 收集寶藏 (北市賽 2019 pE)",
        "content": "# [題解] TIOJ 2173 收集寶藏 (北市賽 2019 pE)\n## 題意\n兩個人到一個 $n \\times m$ 大的迷宮裡探險 \\\n在迷宮裡只能往右和往下走 \\\n而入口在 $(1, 1)$ 出口在 $(n, m)$ \\\n求離開迷宮最多能帶走多少寶藏 \\\n迷宮示意圖如下\n\n![problem image](https://tioj.ck.tp.edu.tw/pimgs/2173.png)\n\n## 很暴力的 DP\n應該不難聯想到這題 [CSES - Grid Paths](https://cses.fi/problemset/task/1638) \\\n只要把狀態開成四維 \\\n分別代表第一個人的 xy 座標及第二個人的 xy 坐標 \\\n然後可以推出：\n\n$$\\begin{equation}\ndp[i][j][k][l] = grid[i][j] + \\text{max} \n\\begin{cases} \ndp[i-1][j][k-1][l] \\\\\ndp[i-1][j][k][l-1] \\\\\ndp[i][j-1][k-1][l] \\\\\ndp[i][j-1][k][l-1] \\\\\n\\end{cases}\n\\end{equation}$$\n\n不過加上 $grid[i][j]$ 的部份有些細節要處理 \\\n詳細轉移的部份自己看下面的程式碼\n\n在本地測試了一下就順利通過了範測 ouob\n\n## 快樂壓常時間\n結果剛剛的作法傳上去之後很快就拿到 TLE 了 \\\n於是就想說順便來嘗試看看最近剛學到的壓常小技巧\n```cpp\n#define int short\n```\n加上去後通過了更多比測資但依然還是 TLE\n\n又仔細思考了一下題目 \\\n發現 $i + j \\neq k + l$ 的狀態一定不合法 \\\n所以就把不合法的狀態 continue 掉\n\n然後就神奇的成功壓常 AC 了 :D\n\n## 程式碼\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#define int short\n#define endl \"\\n\"\n\nconst int MAXN = 1e2 + 3;\nconst int INF = 32000;\n\nint mp[MAXN][MAXN];\nint dp[MAXN][MAXN][MAXN][MAXN];\n\nsigned main() {\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    int n, m;\n    cin >> n >> m;\n    // 把邊界都設定為 -INF\n    for (int i = 0; i <= n + 1; i++) {\n        for (int j = 0; j <= m + 1; j++) {\n            for (int k = 0; k <= n + 1; k++) {\n                for (int l = 0; l <= m + 1; l++) {\n                    if (i == 0 || i == n+1 || j == 0 || j == m+1 || k == 0 || k == n+1 || l == 0 || l == m+1) {\n                        dp[i][j][k][l] = -INF;\n                    }\n                }\n            }\n        }\n    }\n    // 初始狀態\n    dp[0][0][0][0] = 0;\n    dp[0][1][0][1] = 0;\n    dp[1][0][1][0] = 0;\n    dp[0][1][1][0] = 0;\n    dp[1][1][1][1] = 0;\n    // 輸入整張地圖\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= m; j++) {\n            cin >> mp[i][j];\n        }\n    }\n    // DP\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= m; j++) {\n            for (int k = 1; k <= n; k++) {\n                for (int l = 1; l <= m; l++) {\n                    // 一點點剪枝\n                    if (i + j != k + l) continue;\n                    if (mp[i][j] == -1 || mp[k][l] == -1) {\n                        dp[i][j][k][l] = -INF;\n                        continue;\n                    }\n                    // 轉移\n                    dp[i][j][k][l] = max({\n                        dp[i-1][j][k-1][l],\n                        dp[i-1][j][k][l-1],\n                        dp[i][j-1][k-1][l],\n                        dp[i][j-1][k][l-1],\n                    });\n                    // 拿到寶藏增加分數\n                    dp[i][j][k][l] += (mp[i][j] == 1) + (mp[k][l] == 1) * (i != k || j != l);\n                }\n            }\n        }\n    }\n    // 輸出答案\n    cout << max(dp[n][m][n][m], (short)0) << endl;\n}\n```\n",
        "category": "TIOJ",
        "date": "2024 / 01 / 01"
    },
    {
        "id": "harmonic-series",
        "title": "調和級數",
        "content": "# 調和級數\n## 簡介\n一個在因倍數相關題目可以用到的小技巧 \\\n程式碼大概像這樣 \\\n可以得到 $O(n \\log n)$ 的時間複雜度\n```cpp\nfor (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j += i) {\n        // to something\n    }\n}\n```\n## 公式\n$n \\log n \\approx \\sum_{k=1}^n \\frac 1 k =  1 + \\frac 1 2 + \\frac 1 3 + \\frac 1 4 + \\cdots + \\frac 1 n$ \\\n<br />\n![](https://github.com/dada878/blog/blob/master/assets/Snipaste_2023-09-09_20-53-54.png?raw=true)\n## 例題\nhttps://codeforces.com/contest/1850/problem/F \\\nhttps://cses.fi/problemset/task/1081/",
        "category": "Math",
        "date": "2024 / 01 / 01"
    },
    {
        "id": "modulo-inverse",
        "title": "模反元素",
        "content": "# 模反元素\n頁面待完成...",
        "category": "Math",
        "date": "2024 / 01 / 01"
    }
]